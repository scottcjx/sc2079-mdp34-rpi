Directory Tree:
mdp_ws/
    androidapp.py
    definitions.py
    requirements.txt
    taskserver.py
    sharedResources.py
    car.py
    communication.py
    main.py
    PathFinding_task1/
        visualiser.py
        constants.py
        __init__.py
        game_maker.py
        main_task1.py
        game_solver.py
    ObjectTypes/
        __init__.py
        object_types.py
    ComputerServer/
        __init__.py
        car.png
        data_manager.py
        main.py
    PathFinding_task2/
        visualiser.py
        constants.py
        Task2_Pathfinding_Manager.py
        game_solver.py

File: androidapp.py
import logging
import os
import bluetooth
import time
from queue import Queue, Empty

from protocol import Protocol
from communication import AbstractSerialInterface
from sharedResources import SharedRsc, sharedResources
import definitions

logger = logging.getLogger("AndroidApp")

class AppMessageProtocol:
    sharedResources: SharedRsc = None

    @classmethod
    def init_shared_resources(cls):
        logger.info("[AppMessageProtocol] Initializing shared resources")
        cls.sharedResources.set("TASK.MODE.REQ", Queue(1))
        cls.sharedResources.set("TASK.STATUS.REQ", Queue(1))
        cls.sharedResources.set("APP.MOVE.REQ", Queue(1))

    @classmethod
    def set_shared_resources(cls, shared_resources):
        cls.sharedResources = shared_resources

    @classmethod
    def decode_message(cls, msg: str):
        stripped = msg.strip()
        if not (stripped.startswith("/*") and stripped.endswith("*/")):
            logger.warning("Invalid message format: %s", msg)
            return
        cmdstr = stripped.removeprefix("/*").removesuffix("*/")
        parts = cmdstr.split("=")
        if len(parts) != 2:
            logger.warning("Malformed command: %s", msg)
            return
        cmd, val = parts
        cls.call_cmd(cmd, val)

    @classmethod
    def process_taskmode(cls, val):
        if val not in definitions.MODES:
            logger.warning("Invalid mode: %s", val)
            return
        try:
            cls.sharedResources.get("TASK.MODE.REQ").put_nowait(val)
            logger.info(f"Task mode set to {val}")
        except Exception as e:
            logger.error("Error setting task mode: %s", e)

    @classmethod
    def process_task_status(cls, val):
        if val not in definitions.TASKSTATUSES:
            logger.warning("Invalid task status: %s", val)
            return
        try:
            cls.sharedResources.get("TASK.STATUS.REQ").put_nowait(val)
            logger.info(f"Task status set to {val}")
        except Exception as e:
            logger.error("Error setting task status: %s", e)

    @classmethod
    def process_mmove(cls, val):
        if val not in definitions.MOVES:
            logger.warning("Invalid move command: %s", val)
            return
        try:
            cls.sharedResources.get("APP.MOVE.REQ").put_nowait(val)
            logger.info(f"Move command received: {val}")
        except Exception as e:
            logger.error("Error processing move command: %s", e)

    @classmethod
    def process_map(cls, val):
        if (cls.sharedResources.get("TASK.STATUS") == "IN-PROGRESS" and 
            str(cls.sharedResources.get("TASK.MODE")).startswith("TASK")):
            logger.warning("Map update rejected; task in progress.")
            return
        cls.sharedResources.set("MAP.NEW.FLAG", 1)
        cls.sharedResources.set("MAP.STR", val)
        logger.info(f"Map updated: {val}")

    @classmethod
    def call_cmd(cls, cmd, val):
        cmds = {
            "TASKMODE": cls.process_taskmode,
            "TASKSTATUSREQ": cls.process_task_status,
            "MMOVE": cls.process_mmove,
            "MAP": cls.process_map,
        }
        if cmd in cmds:
            cmds[cmd](val)
        else:
            logger.warning("Unknown command received: %s", cmd)

class AppInterface(AbstractSerialInterface):
    sharedResources: SharedRsc = None
    msg_protocol_cls = AppMessageProtocol

    def setup_protocol(self):
        self.msg_protocol_cls.set_shared_resources(self.sharedResources)
        self.msg_protocol_cls.init_shared_resources()

    def set_shared_resources(self, shared_resources):
        self.sharedResources = shared_resources

    def rx_callback(self, msg):
        # Automatically process the message via the protocol.
        logger.info(f"Android RX: {msg}")
        self.msg_protocol_cls.decode_message(msg)

    def setup_bluetooth(self, bt_port=1, bind_timeout=10):
        self.bt_port = bt_port
        logger.info("Setting up Bluetooth on port %d", bt_port)
        os.system("sudo hciconfig hci0 piscan")
        os.system(f"sudo sdptool add --channel={bt_port} SP")
        os.system(f"sudo rfcomm listen 0 {bt_port} &")
        server_sock = bluetooth.BluetoothSocket(bluetooth.RFCOMM)
        start_time = time.time()
        while True:
            try:
                server_sock.bind(("", bt_port))
                server_sock.listen(1)
                logger.info(f"[BT] Bound to port {bt_port}")
                break
            except Exception as e:
                logger.error("[BT] Could not bind to port %d: %s", bt_port, e)
                if time.time() - start_time > bind_timeout:
                    logger.error("Bluetooth bind timeout reached.")
                    break
                time.sleep(1)
        logger.info(f"[BT] Waiting for connection on RFCOMM channel {bt_port}")

class AndroidApp:
    def __init__(self, port):
        self.interface = AppInterface(port=port, baudrate=115200)
        self.interface.set_shared_resources(sharedResources)
        self.interface.setup_protocol()

    def connect(self):
        self.interface.connect()

    def disconnect(self):
        self.interface.disconnect()

    def send_command(self, command: str):
        """Standardized API to send any command from Android side."""
        self.interface.tx(command)
        logger.info(f"Sent command from Android: {command}")

    def transmit_map_details(self):
        """Sends map details using the standardized API."""
        command = "MAP_DETAILS"  # Placeholder for the actual command format.
        self.send_command(command)

    def transmit_bot_location(self):
        """Sends bot location using the standardized API."""
        command = "BOT_LOCATION"  # Placeholder for the actual command format.
        self.send_command(command)

--------------------------------------------------------------------------------
File: definitions.py


MODES = ["MANUAL", "TASK1", "TASK2", "TASKB"]
TASKSTATUSES = ["START", "PAUSE", "STOP", "IN-PROGRESS"]
MOVES = ["F", "B", "L", "R"]
--------------------------------------------------------------------------------
File: taskserver.py
import threading
import time
import logging
from queue import Queue, Empty
from sharedResources import SharedRsc, sharedResources
from definitions import *
from car import Car
from androidapp import AndroidApp

logger = logging.getLogger("TaskServer")

class TaskServer:
    def __init__(self, car: Car, android_app: AndroidApp, shared_resources: SharedRsc):
        self.car = car
        self.android_app = android_app
        self.shared_resources = shared_resources
        self.current_mode = "MANUAL"
        self.mode_changed = False
        self._running = False
        self.loop_thread = None

        # Ensure mode request queue exists
        if not self.shared_resources.get("TASK.MODE.REQ"):
            self.shared_resources.set("TASK.MODE.REQ", Queue(1))

    def setup_manual(self):
        logger.info("[TaskServer] Setting up MANUAL mode")
        self.shared_resources.set("APP.MOVE.REQ", Queue(1))
    
    def loop_manual(self):
        logger.debug("[TaskServer] Loop MANUAL mode")
        try:
            move_cmd = self.shared_resources.get("APP.MOVE.REQ").get_nowait()
            # Use standardized API: move_standard for Car.
            self.car.move(move_cmd)
        except Empty:
            pass

    def setup_task1(self):
        logger.info("[TaskServer] Setting up TASK1 mode")
        # TODO: Initialize components specific to TASK1.
        pass

    def loop_task1(self):
        logger.debug("[TaskServer] Loop TASK1 mode")
        # TODO: Add processing logic for TASK1.
        pass

    def setup_task2(self):
        logger.info("[TaskServer] Setting up TASK2 mode")
        # TODO: Initialize components specific to TASK2.
        pass

    def loop_task2(self):
        logger.debug("[TaskServer] Loop TASK2 mode")
        # TODO: Add processing logic for TASK2.
        pass

    def setup_taskB(self):
        logger.info("[TaskServer] Setting up TASKB mode")
        # TODO: Initialize components specific to TASKB.
        pass

    def loop_taskB(self):
        logger.debug("[TaskServer] Loop TASKB mode")
        # TODO: Add processing logic for TASKB.
        pass

    def setup(self):
        logger.info("[TaskServer] Setup")
        self.shared_resources.set("TASK.MODE", "MANUAL")
        self.setup_manual()

    def _handle_mode_change(self):
        try:
            mode_queue = self.shared_resources.get("TASK.MODE.REQ")
            new_mode = mode_queue.get_nowait()
            self.shared_resources.set("TASK.MODE", new_mode)
            self.current_mode = new_mode
            self.mode_changed = True
            logger.info(f"Switched to mode: {new_mode}")
        except Empty:
            pass

    def loop(self):
        self._running = True
        while self._running:
            self.mode_changed = False
            self._handle_mode_change()
            mode = self.shared_resources.get("TASK.MODE")
            if mode is None:
                mode = "MANUAL"
                self.shared_resources.set("TASK.MODE", mode)
            if mode == "MANUAL":
                if self.mode_changed:
                    self.setup_manual()
                self.loop_manual()
            elif mode == "TASK1":
                if self.mode_changed:
                    self.setup_task1()
                self.loop_task1()
            elif mode == "TASK2":
                if self.mode_changed:
                    self.setup_task2()
                self.loop_task2()
            elif mode == "TASKB":
                if self.mode_changed:
                    self.setup_taskB()
                self.loop_taskB()
            else:
                logger.warning("Unknown mode: %s", mode)
            time.sleep(0.05)

    def start(self):
        if self.loop_thread is None or not self.loop_thread.is_alive():
            self.loop_thread = threading.Thread(target=self.loop, daemon=True)
            self.loop_thread.start()
            logger.info("TaskServer started.")

    def stop(self):
        self._running = False
        if self.loop_thread:
            self.loop_thread.join()
            logger.info("TaskServer stopped.")

--------------------------------------------------------------------------------
File: sharedResources.py
from queue import Queue


class SharedRsc:
    data = {}

    def __init__(self):
        pass

    @classmethod
    def set(cls, key: str, val):
        cls.data[key] = val    
    
    @classmethod
    def get(cls, key):
        return cls.data.get(key, None)

sharedResources = SharedRsc()

--------------------------------------------------------------------------------
File: car.py
import logging
from communication import AbstractSerialInterface
from sharedResources import SharedRsc, sharedResources
from queue import Queue
import definitions

logger = logging.getLogger("Car")

class CarMessageProtocol:
    sharedResources = None

    @classmethod
    def init_shared_resources(cls):
        logger.info("[CarMessageProtocol] Initializing shared resources")
        cls.sharedResources.set("CAR.MOVE.REQ", Queue(1))
        cls.sharedResources.set("CAR.STATUS", "IDLE")

    @classmethod
    def set_shared_resources(cls, shared_resources):
        cls.sharedResources = shared_resources

    @classmethod
    def decode_message(cls, msg):
        try:
            decoded_msg = msg.decode('utf-8').strip()
            logger.debug(f"Car RX Decoded: {decoded_msg}")
            
            # Processing incoming messages from the car
            if decoded_msg.startswith("RANGE"):
                parts = decoded_msg.split()
                if len(parts) >= 2:
                    try:
                        range_value = float(parts[1])
                        cls.sharedResources.set("CAR.RANGE", range_value)
                        logger.info(f"Updated car range: {range_value}")
                    except ValueError:
                        logger.warning(f"Invalid range value: {parts[1]}")
            
            elif decoded_msg.startswith("GYRO:"):
                # Process GYRO data - z-bearing only
                try:
                    # Extract the value after "GYRO: "
                    gyro_str = decoded_msg.replace("GYRO:", "").strip()
                    z_bearing = float(gyro_str)
                    cls.sharedResources.set("CAR.GYRO.Z", z_bearing)
                    logger.debug(f"Updated car z-bearing: {z_bearing}")
                except ValueError:
                    logger.warning(f"Invalid GYRO value: {decoded_msg}")
            
            elif decoded_msg.startswith("STATUS"):
                parts = decoded_msg.split()
                if len(parts) >= 2:
                    status = parts[1]
                    cls.sharedResources.set("CAR.STATUS", status)
                    logger.info(f"Updated car status: {status}")
            
            else:
                logger.debug(f"Unhandled car message: {decoded_msg}")
                
        except Exception as e:
            logger.error(f"Error decoding car message: {e}")

    @classmethod
    def encode_move(cls, direction: str, distance: int = 10):
        """
        Encodes a movement command according to the car's protocol.
        
        Args:
            direction: Direction to move ('F', 'B', 'L', 'R')
            distance: Distance value or angle (depends on direction)
            
        Returns:
            Formatted command string for the car
        """
        if direction not in definitions.MOVES:
            logger.warning(f"Invalid direction: {direction}")
            return None
            
        # Format commands according to car's protocol
        if direction == "F":
            return f"SF{str(distance).zfill(3)}"
        elif direction == "B":
            return f"SB{str(distance).zfill(3)}"
        elif direction == "L":
            return f"TL{str(distance).zfill(3)}"
        elif direction == "R":
            return f"TR{str(distance).zfill(3)}"
        
    @classmethod
    def encode_stop(cls):
        """Encodes a stop command for the car."""
        return "STOP"

class CarInterface(AbstractSerialInterface):
    def __init__(self, port, baudrate=115200, timeout=1):
        super().__init__(port, baudrate, timeout)
        self.msg_protocol_cls = CarMessageProtocol
        
    def set_shared_resources(self, shared_resources):
        self.sharedResources = shared_resources
        self.msg_protocol_cls.set_shared_resources(shared_resources)
        
    def setup_protocol(self):
        """Initialize protocol and shared resources"""
        self.msg_protocol_cls.init_shared_resources()
        
    def rx_callback(self, data):
        """Process received data using the protocol decoder"""
        logger.debug(f"Car RX: {data}")
        self.msg_protocol_cls.decode_message(data)

class Car:
    def __init__(self, port):
        self.interface = CarInterface(port=port, baudrate=115200)
        self.interface.set_shared_resources(sharedResources)
        self.interface.setup_protocol()

    def connect(self):
        """Connect to the car hardware"""
        self.interface.connect()

    def disconnect(self):
        """Disconnect from the car hardware"""
        self.interface.disconnect()

    def send_command(self, command: str):
        """
        Standardized API to send any command to the car.
        
        Args:
            command: The formatted command string to send
        """
        if isinstance(command, str):
            command = command.encode('utf-8')
        self.interface.tx(command)
        logger.info(f"Sent command to Car: {command}")

    def move(self, direction: str, distance: int = 10):
        """
        Sends a move command to the car using the standardized protocol.
        
        Args:
            direction: Direction to move ('F', 'B', 'L', 'R')
            distance: Distance value or angle (depends on direction)
        """
        command = CarMessageProtocol.encode_move(direction, distance)
        if command:
            self.send_command(command)
        else:
            logger.error(f"Failed to generate move command for direction: {direction}")

    def stop(self):
        """Sends a stop command to the car."""
        command = CarMessageProtocol.encode_stop()
        self.send_command(command)
--------------------------------------------------------------------------------
File: communication.py
import serial
import threading
import time
from abc import ABC, abstractmethod
from collections import deque

class AbstractSerialInterface(ABC):
    def __init__(self, port, baudrate=115200, timeout=1):
        self.port = port
        self.baudrate = baudrate
        self.timeout = timeout
        self.serial_connection = None
        self.is_connected = False
        self._rx_thread = None
        self._tx_thread = None
        self._rx_callback = None
        self._tx_buffer = deque()  # TX buffer (FIFO queue)
        self._tx_lock = threading.Lock()  # Lock for thread-safe access to the TX buffer

    @abstractmethod
    def rx_callback(self, data):
        """
        Abstract method that will be called when data is received.
        This method should be implemented by subclasses to define
        how to handle the incoming data.
        """
        pass

    def connect(self):
        """
        Establish serial connection.
        """
        if not self.is_connected:
            try:
                self.serial_connection = serial.Serial(
                    self.port, baudrate=self.baudrate, timeout=self.timeout
                )
                self.is_connected = True
                print(f"{self.port} Connected; {self.baudrate} baud.")
                self._start_rx_thread()
                self._start_tx_thread()  # Start the TX thread when connected
            except Exception:
                pass

    def disconnect(self):
        """
        Close serial connection.
        """
        if self.is_connected:
            self.is_connected = False
            if self._rx_thread is not None:
                self._rx_thread.join()  # Wait for the RX thread to finish.
            if self._tx_thread is not None:
                self._tx_thread.join()  # Wait for the TX thread to finish.
            if self.serial_connection:
                self.serial_connection.close()
                print(f"{self.port} Disconnected")
        else:
            print(f"{self.port} No active connection to disconnect.")

    def _start_rx_thread(self):
        """
        Start a background thread to handle data reception.
        """
        def receive_data():
            while self.is_connected:
                if self.serial_connection.in_waiting > 0:
                    data = self.serial_connection.read(self.serial_connection.in_waiting)
                    if self._rx_callback:
                        print(f"{self.port} Data received: {data}")
                        self._rx_callback(data)
                    else:
                        self.rx_callback(data)
                time.sleep(0.1)

        self._rx_thread = threading.Thread(target=receive_data)
        self._rx_thread.daemon = True
        self._rx_thread.start()

    def _start_tx_thread(self):
        """
        Start a background thread to handle data transmission from the TX buffer.
        """
        def transmit_data():
            while self.is_connected:
                with self._tx_lock:
                    if self._tx_buffer:
                        data = self._tx_buffer.popleft()  # Get data from TX buffer
                        self.serial_connection.write(data)
                        print(f"{self.port} tx: {data}")
                time.sleep(0.1)

        self._tx_thread = threading.Thread(target=transmit_data)
        self._tx_thread.daemon = True
        self._tx_thread.start()

    def set_rx_callback(self, callback):
        """
        Set a custom RX callback function.
        """
        self._rx_callback = callback

    def tx(self, data):
        """
        Add data to the TX buffer.
        """
        if self.is_connected:
            with self._tx_lock:
                self._tx_buffer.append(data)  # Add data to TX buffer
                # print(f"{self.port} Data added to TX buffer: {data}")
        else:
            print(f"{self.port} Not connected. Cannot transmit data.")

    def rx(self):
        """
        Return the latest data received from the serial port.
        """
        if self.is_connected:
            data = self.serial_connection.read(self.serial_connection.in_waiting)
            return data
        else:
            print(f"{self.port} Not connected. Cannot receive data.")
            return None


--------------------------------------------------------------------------------
File: main.py
import logging
import time
import threading
from car import Car
from androidapp import AndroidApp
from taskserver import TaskServer
from sharedResources import sharedResources
import definitions

# Set logging level to INFO
logging.basicConfig(level=logging.INFO)

# Mapping of option numbers to command strings.
COMMAND_OPTIONS = {
    "1": "/*TASKMODE=MANUAL*/",
    "2": "/*TASKMODE=TASK1*/",
    "3": "/*TASKMODE=TASK2*/",
    "4": "/*TASKMODE=TASKB*/",
    "5": "/*TASKSTATUSREQ=START*/",
    "6": "/*TASKSTATUSREQ=PAUSE*/",
    "7": "/*TASKSTATUSREQ=STOP*/",
    "8": "/*MMOVE=F*/",
    "9": "/*MMOVE=B*/",
    "10": "/*MMOVE=L*/",
    "11": "/*MMOVE=R*/",
    "12": "/*MAP=[(0, 00, 00, 1),(1, 00, 00, 2)]*/"
}

def display_menu():
    menu = """
Choose a command to send (simulating Android sending to your app):
 1: Set TASKMODE to MANUAL
 2: Set TASKMODE to TASK1
 3: Set TASKMODE to TASK2
 4: Set TASKMODE to TASKB
 5: Set TASKSTATUSREQ to START
 6: Set TASKSTATUSREQ to PAUSE
 7: Set TASKSTATUSREQ to STOP
 8: Send MMOVE command: F
 9: Send MMOVE command: B
10: Send MMOVE command: L
11: Send MMOVE command: R
12: Send MAP update command
Type 'exit' to quit.
"""
    print(menu)

def terminal_interface(android_app: AndroidApp, stop_event: threading.Event):
    """
    Terminal-based input loop that simulates incoming messages from the Android app.
    Instead of sending commands out, it passes them to the Android interface's rx_callback,
    so the message is processed by the app and ultimately by the TaskServer.
    """
    logging.info("Terminal interface started. Use the menu options to send commands.")
    while not stop_event.is_set():
        try:
            display_menu()
            choice = input("Enter option number: ").strip()
            if choice.lower() == "exit":
                stop_event.set()
                break
            command = COMMAND_OPTIONS.get(choice)
            if command:
                logging.info(f"Simulating reception of command: {command}")
                # Simulate the Android interface receiving the command.
                android_app.interface.rx_callback(command)
            else:
                print("Invalid option. Please try again.")
        except Exception as e:
            logging.error("Error in terminal input: %s", e)
            stop_event.set()

def main():
    # Instantiate devices using the standardized APIs.
    car = Car(port='/dev/ttyUSB0')
    android_app = AndroidApp(port='/dev/rfcomm0')
    
    # Create and set up the TaskServer.
    task_server = TaskServer(car, android_app, sharedResources)
    task_server.setup()

    stop_event = threading.Event()
    terminal_thread = threading.Thread(target=terminal_interface, args=(android_app, stop_event), daemon=True)

    try:
        # Connect devices using their public methods.
        if not car.interface.is_connected:
            car.connect()
        if not android_app.interface.is_connected:
            android_app.connect()

        # Start the TaskServer loop in its own thread.
        task_server.start()

        # Start the terminal interface thread.
        terminal_thread.start()

        # Keep the main thread active until "exit" is entered.
        while not stop_event.is_set():
            time.sleep(1)

    except KeyboardInterrupt:
        logging.info("KeyboardInterrupt received. Shutting down...")
        stop_event.set()

    finally:
        # Cleanly stop the TaskServer and disconnect devices.
        task_server.stop()
        car.disconnect()
        android_app.disconnect()
        logging.info("Shutdown complete.")

if __name__ == "__main__":
    main()

--------------------------------------------------------------------------------
File: PathFinding_task1/visualiser.py
import pygame
import math
from typing import List
import random
import numpy as np
from datetime import datetime, timedelta
import time

from ObjectTypes.object_types import (
    GameTask1,
    Position,
    LocationType,
    Facing,
    MinimumPath,
    Direction,
    Movement,
    TravelledSalesman,
)
from PathFinding_task1.constants import (
    WHITE,
    SCALE_FACTOR,
    START_BOX_SIZE,
    YELLOW,
    BLACK,
    GRID_COUNT,
    GRID_SIZE,
    RED,
    GREEN,
    BLUE1,
    CAR_SPEED,
    TURNING_RADIAN_INCREMENT,
    CAR_TURNING_RADIUS,
    RENDER_SPEED,
)

pygame.init()


class Visualiser:

    def __init__(self, width: int = 200, height: int = 200) -> None:
        self.width = width
        self.height = height
        self.display = pygame.display.set_mode(
            (self.width * SCALE_FACTOR, self.height * SCALE_FACTOR)
        )
        pygame.display.set_caption("Path Finding")
        self.car_image = pygame.image.load("car.png").convert_alpha()
        self.car_image = pygame.transform.scale(
            self.car_image, (15 * SCALE_FACTOR, 25 * SCALE_FACTOR)
        )
        self.colors = [self._random_color() for _ in range(10000)]
        self.font = pygame.font.Font(None, 4 * SCALE_FACTOR)

    def _random_color(self):
        return (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))

    def _display_vector(self, start_vector: Position, end_vector: Position, color):
        pygame.draw.line(
            self.display,
            color,
            (
                start_vector.x * SCALE_FACTOR,
                (self.width - start_vector.y) * SCALE_FACTOR,
            ),
            (end_vector.x * SCALE_FACTOR, (self.height - end_vector.y) * SCALE_FACTOR),
            width=3,
        )

    def _display_turn(self, movement: Movement, color):

        if movement.circle_center is None:
            return

        circle_center_to_start = [
            movement.start_position.x - movement.circle_center.x,
            movement.start_position.y - movement.circle_center.y,
        ]
        circle_center_to_end = [
            movement.end_position.x - movement.circle_center.x,
            movement.end_position.y - movement.circle_center.y,
        ]
        start_rad = np.arctan2(circle_center_to_start[1], circle_center_to_start[0]) % (
            2 * np.pi
        )
        end_rad = np.arctan2(circle_center_to_end[1], circle_center_to_end[0]) % (
            2 * np.pi
        )

        if (movement.direction == Direction.left and movement.distance_cm > 0) or (
            movement.direction == Direction.right and movement.distance_cm < 0
        ):
            rad_1 = start_rad
            rad_2 = end_rad
        else:
            rad_1 = end_rad
            rad_2 = start_rad

        pygame.draw.arc(
            self.display,
            color,
            pygame.Rect(
                (
                    movement.circle_center.x * SCALE_FACTOR
                    - CAR_TURNING_RADIUS * SCALE_FACTOR,
                    (self.height - movement.circle_center.y) * SCALE_FACTOR
                    - CAR_TURNING_RADIUS * SCALE_FACTOR,
                ),
                (
                    CAR_TURNING_RADIUS * SCALE_FACTOR * 2,
                    CAR_TURNING_RADIUS * SCALE_FACTOR * 2,
                ),
            ),
            rad_1,
            rad_2,
            CAR_TURNING_RADIUS * SCALE_FACTOR,
        )

    def _determine_car_position(
        self, sale_path: TravelledSalesman, distance_covered: float
    ):

        index = 0
        working_distance_covered = distance_covered
        while working_distance_covered > 0 and index < len(sale_path.movement_path):
            working_distance_covered -= abs(sale_path.movement_path[index].distance_cm)
            index += 1

        if index == len(sale_path.movement_path) and working_distance_covered > 0:
            self.running = False
        current_movement = sale_path.movement_path[index - 1]
        self._move_car(movement=current_movement)
        # print(f"Car is currently travelling {current_movement.direction}")

    def display_game_frame(
        self,
        distance_matrix: List[List[MinimumPath]],
        sale_path: TravelledSalesman,
    ):
        self.display.fill(WHITE)

        distance_covered = self.clock * CAR_SPEED
        self._determine_car_position(
            sale_path=sale_path, distance_covered=distance_covered
        )

        # print(time_since.seconds)
        ## Drawing Start Box
        pygame.draw.rect(
            self.display,
            YELLOW,
            pygame.Rect(
                0,
                (self.height - START_BOX_SIZE) * SCALE_FACTOR,
                START_BOX_SIZE * SCALE_FACTOR,
                START_BOX_SIZE * SCALE_FACTOR,
            ),
        )

        ## Drawing grid
        for i in range(GRID_COUNT):
            pygame.draw.line(
                self.display,
                BLACK,
                (0, i * GRID_SIZE * SCALE_FACTOR),
                (self.width * SCALE_FACTOR, i * GRID_SIZE * SCALE_FACTOR),
            )
            pygame.draw.line(
                self.display,
                BLACK,
                (i * GRID_SIZE * SCALE_FACTOR, 0),
                (i * GRID_SIZE * SCALE_FACTOR, self.height * SCALE_FACTOR),
            )

        seq_str = "5"
        for src_index in range(len(sale_path.obstacle_seq)):
            dest_index = (src_index + 1) % len(sale_path.obstacle_seq)
            y = sale_path.obstacle_seq[src_index]
            x = sale_path.obstacle_seq[dest_index]

            seq_str += f" -> {x}"
            if y == x:
                continue
            color = self.colors[y * GRID_COUNT + x]
            for path in distance_matrix[y][x].movements_to_take:
                start_pos = path.start_position
                end_pos = path.end_position
                movement_direction = path.direction

                if path.direction == Direction.straight:
                    self._display_vector(
                        start_vector=start_pos, end_vector=end_pos, color=color
                    )
                else:
                    self._display_turn(movement=path, color=color)
        for row in self.game.arena:
            for col in row:

                if col.locationType == LocationType.landing_padding:
                    # pygame.draw.rect(
                    #     self.display,
                    #     RED,
                    #     pygame.Rect(
                    #         (col.x * GRID_SIZE) * SCALE_FACTOR,
                    #         (self.height - (col.y + 1) * GRID_SIZE) * SCALE_FACTOR,
                    #         GRID_SIZE * SCALE_FACTOR,
                    #         GRID_SIZE * SCALE_FACTOR,
                    #     ),
                    # )
                    pass
                elif col.locationType == LocationType.obstacle:
                    pygame.draw.rect(
                        self.display,
                        BLUE1,
                        pygame.Rect(
                            (col.x * GRID_SIZE) * SCALE_FACTOR,
                            (self.height - (col.y + 1) * GRID_SIZE) * SCALE_FACTOR,
                            (GRID_SIZE) * SCALE_FACTOR,
                            (GRID_SIZE) * SCALE_FACTOR,
                        ),
                    )
                    text_surface = self.font.render(str(col.id), True, (255, 255, 255))
                    text_rect = text_surface.get_rect()
                    text_rect.center = (
                        (col.x * GRID_SIZE + GRID_SIZE / 2) * SCALE_FACTOR,
                        (self.height - (col.y + 1) * GRID_SIZE + GRID_SIZE / 2)
                        * SCALE_FACTOR,
                    )
                    self.display.blit(text_surface, text_rect)
                    if col.facing == Facing.east:
                        pygame.draw.rect(
                            self.display,
                            YELLOW,
                            pygame.Rect(
                                (col.x * GRID_SIZE + GRID_SIZE - 3) * SCALE_FACTOR,
                                (self.height - (col.y + 1) * GRID_SIZE) * SCALE_FACTOR,
                                (3) * SCALE_FACTOR,
                                (GRID_SIZE) * SCALE_FACTOR,
                            ),
                        )
                    elif col.facing == Facing.north:
                        pygame.draw.rect(
                            self.display,
                            YELLOW,
                            pygame.Rect(
                                (col.x * GRID_SIZE) * SCALE_FACTOR,
                                (self.height - (col.y + 1) * GRID_SIZE) * SCALE_FACTOR,
                                (GRID_SIZE) * SCALE_FACTOR,
                                (3) * SCALE_FACTOR,
                            ),
                        )
                    elif col.facing == Facing.west:
                        pygame.draw.rect(
                            self.display,
                            YELLOW,
                            pygame.Rect(
                                (col.x * GRID_SIZE) * SCALE_FACTOR,
                                (self.height - (col.y + 1) * GRID_SIZE) * SCALE_FACTOR,
                                (3) * SCALE_FACTOR,
                                (GRID_SIZE) * SCALE_FACTOR,
                            ),
                        )
                    elif col.facing == Facing.south:
                        pygame.draw.rect(
                            self.display,
                            YELLOW,
                            pygame.Rect(
                                (col.x * GRID_SIZE) * SCALE_FACTOR,
                                (self.height - (col.y + 1) * GRID_SIZE + GRID_SIZE - 3)
                                * SCALE_FACTOR,
                                (GRID_SIZE) * SCALE_FACTOR,
                                (3) * SCALE_FACTOR,
                            ),
                        )

                # elif col.locationType == LocationType.landing:
                #     color = GREEN
                #     pygame.draw.rect(
                #         self.display,
                #         color,
                #         pygame.Rect(
                #             (col.x * GRID_SIZE) * SCALE_FACTOR,
                #             (self.height - (col.y + 1) * GRID_SIZE) * SCALE_FACTOR,
                #             GRID_SIZE * SCALE_FACTOR,
                #             GRID_SIZE * SCALE_FACTOR,
                #         ),
                #     )
                #     text_surface = self.font.render(str(col.id), True, (0, 0, 0))
                #     text_rect = text_surface.get_rect()
                #     text_rect.center = (
                #         (col.x * GRID_SIZE + GRID_SIZE / 2) * SCALE_FACTOR,
                #         (self.height - (col.y + 1) * GRID_SIZE + GRID_SIZE / 2)
                #         * SCALE_FACTOR,
                #     )
                #     self.display.blit(text_surface, text_rect)

        rotated_image = pygame.transform.rotate(
            self.car_image, math.degrees(self.game.car.facing_radian - math.pi / 2)
        )
        # print(
        #     f"Car x: {self.game.car.current_position.x} Car y: {self.game.car.current_position.y}"
        # )
        rotated_rect = rotated_image.get_rect(
            center=(
                self.game.car.current_position.x * SCALE_FACTOR,
                (self.height - self.game.car.current_position.y) * SCALE_FACTOR,
            )
        )
        self.display.blit(rotated_image, rotated_rect.topleft)

        text_surface = self.font.render(str(seq_str), True, (0, 0, 0))
        text_rect = text_surface.get_rect()
        text_rect.center = (100, 20)
        self.display.blit(text_surface, text_rect)

        pygame.display.update()  # Update the display after drawing
        self._increment_clock()

    def _increment_clock(self):
        time.sleep(RENDER_SPEED)
        self.clock += 1

    def _print_movement(self, movement: Movement):
        gear = "forward"
        if movement.distance_cm < 0:
            gear = "backward"
        print(f"Car moving {gear}, turning: {movement.direction.name} for distance: {movement.distance_cm} cm\tTurn by {movement.turning_radian}")

    def _move_car(self, movement: Movement):
        x = self.game.car.current_position.x
        y = self.game.car.current_position.y
        current_facing = self.game.car.facing_radian

        # self._print_movement(movement=movement)
        try:
            if movement.direction == Direction.straight and movement.distance_cm > 0:
                new_facing = self.game.car.facing_radian
                delta_x = np.cos(new_facing) * CAR_SPEED
                delta_y = np.sin(new_facing) * CAR_SPEED
                new_x = x + delta_x
                new_y = y + delta_y
            elif movement.direction == Direction.straight and movement.distance_cm < 0:
                new_facing = self.game.car.facing_radian
                delta_x = np.cos(new_facing) * CAR_SPEED
                delta_y = np.sin(new_facing) * CAR_SPEED
                new_x = x - delta_x
                new_y = y - delta_y
            elif movement.direction == Direction.left and movement.distance_cm > 0:
                new_facing = (current_facing + TURNING_RADIAN_INCREMENT) % (math.pi * 2)
                center_x = x - CAR_TURNING_RADIUS * np.sin(current_facing)
                center_y = y + CAR_TURNING_RADIUS * np.cos(current_facing)
                new_x = center_x + CAR_TURNING_RADIUS * np.sin(
                    current_facing + TURNING_RADIAN_INCREMENT
                )
                new_y = center_y - CAR_TURNING_RADIUS * np.cos(
                    current_facing + TURNING_RADIAN_INCREMENT
                )

            elif movement.direction == Direction.left and movement.distance_cm < 0:
                new_facing = (current_facing - TURNING_RADIAN_INCREMENT) % (math.pi * 2)
                center_x = x + CAR_TURNING_RADIUS * np.sin(current_facing)
                center_y = y - CAR_TURNING_RADIUS * np.cos(current_facing)
                new_x = center_x - CAR_TURNING_RADIUS * np.sin(
                    current_facing + TURNING_RADIAN_INCREMENT
                )
                new_y = center_y + CAR_TURNING_RADIUS * np.cos(
                    current_facing + TURNING_RADIAN_INCREMENT
                )

            elif movement.direction == Direction.right and movement.distance_cm > 0:
                new_facing = (current_facing - TURNING_RADIAN_INCREMENT) % (math.pi * 2)
                center_x = x + CAR_TURNING_RADIUS * np.sin(current_facing)
                center_y = y - CAR_TURNING_RADIUS * np.cos(current_facing)
                new_x = center_x - CAR_TURNING_RADIUS * np.sin(
                    current_facing - TURNING_RADIAN_INCREMENT
                )
                new_y = center_y + CAR_TURNING_RADIUS * np.cos(
                    current_facing - TURNING_RADIAN_INCREMENT
                )

            elif movement.direction == Direction.right and movement.distance_cm < 0:
                new_facing = (current_facing + TURNING_RADIAN_INCREMENT) % (math.pi * 2)
                center_x = x - CAR_TURNING_RADIUS * np.sin(current_facing)
                center_y = y + CAR_TURNING_RADIUS * np.cos(current_facing)
                new_x = center_x + CAR_TURNING_RADIUS * np.sin(
                    current_facing - TURNING_RADIAN_INCREMENT
                )
                new_y = center_y - CAR_TURNING_RADIUS * np.cos(
                    current_facing - TURNING_RADIAN_INCREMENT
                )

            self.game.car.current_position.x = new_x
            self.game.car.current_position.y = new_y
            self.game.car.facing_radian = new_facing
        except Exception as e:
            print(movement)

    def _print_movement_path(self, sale_path: TravelledSalesman):
        for move in sale_path.movement_path:
            print(f"Move {move.direction} in {move.distance_cm}cm")

    def display_game(
        self,
        game: GameTask1,
        distance_matrix: List[List[MinimumPath]],
        sale_path: TravelledSalesman,
            mapping: dict
    ):
        self.running = True
        self.clock = 0
        self.game = game
        self.mapping = mapping
        print("Starting pygame display")
        # self._print_movement_path(sale_path=sale_path)
        while self.running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False

            self.display_game_frame(
                distance_matrix=distance_matrix, sale_path=sale_path
            )

        pygame.quit()


# if __name__ == "__main__":
#     visualizer = Visualiser()
#     running = True
#     while running:
#         for event in pygame.event.get():
#             if event.type == pygame.QUIT:
#                 running = False

#         visualizer.display_game()

#     pygame.quit()

--------------------------------------------------------------------------------
File: PathFinding_task1/constants.py
from ObjectTypes.object_types import Direction

WHITE = (255, 255, 255)
RED = (252, 203, 199)
BLUE1 = (0, 0, 255)
BLUE2 = (0, 100, 255)
BLACK = (0, 0, 0)
YELLOW = (255, 255, 0)
DARK_RED = (139, 0, 0)
LIGHT_RED = (255, 102, 102)
DARK_BLUE = (0, 0, 139)
LIGHT_BLUE = (173, 216, 230)
DARK_GRAY = (169, 169, 169)
LIGHT_GRAY = (211, 211, 211)
GREEN = (217, 255, 230)
DARK_GREEN = (0, 100, 0)
ORANGE = (255, 165, 0)
PURPLE = (128, 0, 128)
PINK = (255, 192, 203)
CYAN = (0, 255, 255)
MAGENTA = (255, 0, 255)

SCALE_FACTOR = 4
START_BOX_SIZE = 30
GRID_COUNT = 20
CAR_X_START_POS = 15
CAR_Y_START_POS = 5
OBSTACLE_COUNT = 5
ARENA_SIZE = 200
REVERSE_STRAIGHT_DISTANCE = 15
CAR_SPEED = 1
CAR_TURNING_RADIUS = 31
RENDER_SPEED = 0.01
TURNING_RADIAN_INCREMENT = CAR_SPEED / CAR_TURNING_RADIUS
GRID_SIZE = ARENA_SIZE // GRID_COUNT
LOWER_GRID_BOUND = 5
HIGHER_GRID_BOUND = 195
CAR_BACK_TO_CENTER = 8

MOVING_TAG = "MOVING_TO:"
REACHED_TAG = "REACHED:"
SAFETY_DISTANCE_EDGE = 3
SAFETY_DISTANCE_OBSTACLE = 15
SAFETY_DISTANCE_TURNING_OBSTACLE = 45
SAFETY_DISTANCE_TURNING_EDGE = 30
LANDING_DISTANCE = 2
ANGLE_SUPPLEMENT = 0

TURNING_EDGE_DISTANCE_FROM_OBSTACLE = 15
LANDING_SUPPLEMENT = 10
LEGAL_MOVES = [
    [Direction.left, Direction.straight, Direction.left],  # Done 0
    [Direction.left, Direction.straight, Direction.right],  # Done 1
    [Direction.left, Direction.right, Direction.left], # 2
    [Direction.right, Direction.straight, Direction.left],  # Done 3
    [Direction.right, Direction.straight, Direction.right],  # Done 4
    [Direction.right, Direction.left, Direction.right], #5
    [Direction.reverse_right, Direction.straight, Direction.left], #6
    [Direction.reverse_right, Direction.straight, Direction.right], #7
    [Direction.reverse_left, Direction.straight, Direction.left], #8
    [Direction.reverse_left, Direction.straight, Direction.right] #9
]

--------------------------------------------------------------------------------
File: PathFinding_task1/__init__.py

--------------------------------------------------------------------------------
File: PathFinding_task1/game_maker.py
from ObjectTypes.object_types import Position, Facing, LocationType, Car, GameTask1, Direction
from constants import CAR_X_START_POS, CAR_Y_START_POS, OBSTACLE_COUNT, GRID_COUNT

import math
from typing import List, Type
import random
from pydantic import BaseModel
import json
from enum import Enum


class GameMaker:
    def __init__(self) -> None:
        self.car = Car(
            current_position=Position(
                y=CAR_Y_START_POS,
                x=CAR_X_START_POS,
                locationType=LocationType.empty,
                facing=Facing.north,
                result="Home",
            ),
            facing_radian=math.pi / 2,
        )

    def make_game(self):
        arena = [
            [
                Position(x=b, y=a, locationType=LocationType.empty)
                for b in range(GRID_COUNT)
            ]
            for a in range(GRID_COUNT)
        ]
        arena = self.randomly_place_obstacles(arena=arena)

        game = GameTask1(arena=arena, car=self.car)
        return game

    def randomly_place_obstacles(self, arena: List[List[Position]]):
        obstacle_count = 0

        def check_possible_object_placement(
            x_potential: int, y_potential: int, facing_potential: Facing
        ) -> bool:
            nonlocal arena

            if facing_potential == Facing.east:
                if (
                    y_potential == 0
                    or y_potential == GRID_COUNT - 1
                    or x_potential > 15
                ):
                    return False
                for y in range(y_potential - 1, y_potential + 2):
                    for x in range(x_potential + 1, x_potential + 5):
                        if arena[y][x].locationType != LocationType.empty:
                            return False

            elif facing_potential == Facing.north:
                if (
                    x_potential == 0
                    or x_potential == GRID_COUNT - 1
                    or y_potential > 15
                ):
                    return False
                for y in range(y_potential + 1, y_potential + 5):
                    for x in range(x_potential - 1, x_potential + 2):
                        if arena[y][x].locationType != LocationType.empty:
                            return False

            elif facing_potential == Facing.west:
                if y_potential == 0 or y_potential == GRID_COUNT - 1 or x_potential < 4:
                    return False
                for y in range(y_potential - 1, y_potential + 2):
                    for x in range(x_potential - 4, x_potential):
                        if arena[y][x].locationType != LocationType.empty:
                            return False

            elif facing_potential == Facing.south:
                if x_potential == 0 or x_potential == GRID_COUNT - 1 or y_potential < 4:
                    return False
                for y in range(y_potential - 4, y_potential):
                    for x in range(x_potential - 1, x_potential + 2):
                        if arena[y][x].locationType != LocationType.empty:
                            return False

            return True

        while obstacle_count < OBSTACLE_COUNT:
            x_potential = random.randint(0, GRID_COUNT - 1)
            y_potential = random.randint(0, GRID_COUNT - 1)
            facing_potential = Facing(value=random.randint(0, 3))

            if x_potential < 5 and y_potential < 5:  ##In Start Box
                continue

            elif check_possible_object_placement(
                x_potential=x_potential,
                y_potential=y_potential,
                facing_potential=facing_potential,
            ):
                arena[y_potential][x_potential].locationType = LocationType.obstacle
                arena[y_potential][x_potential].facing = facing_potential
                arena[y_potential][x_potential].result = f"obstacle {obstacle_count}"
                obstacle_count += 1

        return arena


def save_pydantic_model_to_json(obj: BaseModel, file_path: str) -> None:
    def encode_enum(enum):
        if isinstance(enum, Enum):
            return enum.value
        raise TypeError(f"Object of type {type(enum)} is not serializable")

    def default_serializer(obj):
        if isinstance(obj, BaseModel):
            return obj.dict()
        if isinstance(obj, Enum):
            return encode_enum(obj)
        raise TypeError(f"Object of type {type(obj)} is not serializable")

    with open(file_path, "w") as file:
        json.dump(obj, file, default=default_serializer, indent=4)

--------------------------------------------------------------------------------
File: PathFinding_task1/main_task1.py
from game_maker import GameMaker
from visualiser import Visualiser
from game_solver import GameSolverTask1
from ObjectTypes.object_types import Position, LocationType, Facing



class Task1_Manager:
    def __init__(self):
        do_while_flage = 0
        while do_while_flage == 0:
            game = game_maker_manager.make_game()
            game_solver_manager = GameSolverTask1(game=game)
            game, distance_matrix, sale_path = game_solver_manager.solve()

            if game != None:
                do_while_flage = 1

        self.game = game
        self.distance_matrix = distance_matrix
        self.sale_path = sale_path


if __name__ == "__main__":
    game_maker_manager = GameMaker()
    visualiser_manager = Visualiser()

    # src = Position(x=100, y=0, locationType=LocationType.empty, facing=Facing.north)
    # dest = Position(x=0,y=100,locationType=LocationType.empty, facing=Facing.north)

    # src = Position(x=30, y=80, locationType=LocationType.empty, facing=Facing.west)
    # dest = Position(x=30,y=0,locationType=LocationType.empty, facing=Facing.east)

    # dest = Position(x=6, y=0, locationType=LocationType.empty, facing=Facing.east)
    # src = Position(x=0,y=100,locationType=LocationType.empty, facing=Facing.east)

    do_while_flage = 0
    while do_while_flage == 0:
        game = game_maker_manager.make_game()
        game_solver_manager = GameSolverTask1(game=game)
        game, distance_matrix, sale_path = game_solver_manager.solve()

        if game != None:
            do_while_flage = 1
    # game_solver_manager.solve_move_safe_path(move_index=2, src=src, dest=dest)
    visualiser_manager.display_game(game=game, distance_matrix=distance_matrix, sale_path=sale_path)

--------------------------------------------------------------------------------
File: PathFinding_task1/game_solver.py
import json

from ObjectTypes.object_types import (
    GameTask1,
    Position,
    LocationType,
    Facing,
    Direction,
    MinimumPath,
    Movement,
    TravelledSalesman,

)
from PathFinding_task1.constants import *
import math
from typing import List
import numpy as np


class GameSolverTask1:

    def __init__(self, game: GameTask1) -> None:
        self.game = game
        self._initialize()
        self.edges = [[Position(x=0,y=0, locationType = LocationType.empty), Position(x=0,y=200, locationType = LocationType.empty)],
                 [Position(x=0,y=200, locationType = LocationType.empty), Position(x=200,y=200, locationType = LocationType.empty)],
                 [Position(x=0,y=0, locationType = LocationType.empty), Position(x=200,y=0, locationType = LocationType.empty)],
                 [Position(x=200,y=0, locationType = LocationType.empty), Position(x=200,y=200, locationType = LocationType.empty)]]
        self.landing_supplement = LANDING_SUPPLEMENT
        self.safety_distance_obstacle = SAFETY_DISTANCE_OBSTACLE
        self.safety_distance_edge = SAFETY_DISTANCE_EDGE
        self.safety_distance_turning_edge = SAFETY_DISTANCE_TURNING_EDGE
        self.safety_distance_turning_obstacle = SAFETY_DISTANCE_TURNING_OBSTACLE
    def _initialize(self):
        self.goals = []
        self.sale_path = None
        self.goals_to_id_mapping = {}
        self.shortest_distance_matrix = None
        self.check_edge = True
        self.obstacle = []
        for y in range(len(self.game.arena)):
            for x in range(len(self.game.arena[y])):
                if self.game.arena[y][x].locationType == LocationType.obstacle:
                    self.obstacle.append(self.game.arena[y][x])

    def _find_obstacle_locations(self):
        self.obstacle = []
        for y in range(len(self.game.arena)):
            for x in range(len(self.game.arena[y])):
                if self.game.arena[y][x].locationType == LocationType.obstacle:
                    self.obstacle.append(self.game.arena[y][x])

    def solve(self):

        self._plan_landing_zones()
        # print(self.game, "is Game")
        if self.game is None:
            return self.game, None, None
        self.goals.append(
            Position(
                x=CAR_X_START_POS, y=CAR_Y_START_POS, locationType=LocationType.empty
            )
        )


        self._populate_matrix()
        self._let_salesman_travel()
        # self._label_obstacles()
        if self.sale_path is None:
            if self.landing_supplement >= 15:
                self.landing_supplement *= 0.75
            elif self.safety_distance_obstacle >= 20:
                self.safety_distance_obstacle *= 0.75


            elif self.safety_distance_turning_edge >= 30:
                self.safety_distance_turning_edge *= 0.9
            elif self.safety_distance_turning_obstacle >= 45:
                self.safety_distance_turning_obstacle *= 0.9
            elif self.check_edge:                  
                self.check_edge = False            
            else:
                raise Exception("Really no solution possible")
            # print(f"{self.game=}")
            return self.solve()
        return (
            self.game,
            self.shortest_distance_matrix,
            self.sale_path,
            self.goals_to_id_mapping,
        )


    def _populate_matrix(self):
        for y in range(len(self.shortest_distance_matrix)):
            for x in range(len(self.shortest_distance_matrix)):
                if y == x:
                    continue
                src_initial = self.goals[y]
                dest = self.goals[x]
                value = self._solve_pair(src_initial, dest)
                self.shortest_distance_matrix[y][x] = value
        # self._print_matrix()
        pass

    def _solve_pair(self, src: Position, dest: Position):

        # print(f"Source: x= {src.x} y={src.y} facing={src.facing}")
        min_distance = math.inf
        min_move = []

        for index, move in enumerate(LEGAL_MOVES):
            for reverse_dir in [Direction.straight, Direction.right, Direction.left]:
                after_reverse_src, circle_center = self._find_reverse_dir(
                    pos=src, direction=reverse_dir
                )

                if src.x == CAR_X_START_POS and src.y == CAR_Y_START_POS:
                    moves_to_make = []
                else:
                    if reverse_dir == Direction.straight:
                        moves_to_make = [
                            Movement(
                                distance_cm=-REVERSE_STRAIGHT_DISTANCE,
                                turning_radian=0,
                                direction=reverse_dir,
                                start_position=src,
                                end_position=after_reverse_src,
                            ),
                        ]
                    else:
                        moves_to_make = [
                            Movement(
                                distance_cm=-(math.pi * CAR_TURNING_RADIUS * 2) / 4,
                                turning_radian=math.pi / 2,
                                direction=reverse_dir,
                                start_position=src,
                                end_position=after_reverse_src,
                                circle_center=circle_center,
                            ),
                        ]

                working_distance, working_movement = self._solve_move_safe_path(
                    move_index=index,
                    src=after_reverse_src,
                    dest=dest,
                    moves_to_make=moves_to_make,
                )

                if working_movement is None:
                    continue

                # print("Valid")

                if working_distance < min_distance:

                    min_distance = working_distance
                    min_move = working_movement

        try:
            minimum_path = MinimumPath(
                distance=min_distance, movements_to_take=min_move
            )
            return minimum_path
        except:
            return None

    def _print_matrix(self):

        def print_movement(min_path: MinimumPath):
            print(
                f"Distance: {min_path.distance:.2f}",
                end="\t",
            )

        for y in range(len(self.shortest_distance_matrix)):
            print(f"{y}: ", end=" -> ")
            for x in range(len(self.shortest_distance_matrix)):
                try:
                    print_movement(min_path=self.shortest_distance_matrix[y][x])

                except:
                    print(None, end=" ")

            print("\n")

    def _vector_properties(self, vector):
        length = np.linalg.norm(vector)
        angle_rad = np.arctan2(vector[1], vector[0]) % (2 * np.pi)
        return length, angle_rad

    def _find_reverse_dir(self, pos: Position, direction: Direction):

        if pos.x == CAR_X_START_POS and pos.y == CAR_Y_START_POS:
            new_x = pos.x
            new_y = pos.y
            cirle_x = 0
            circle_y = 0
            new_facing = Facing.north
        else:
            cirle_x, circle_y = self._get_circle_position(position=pos, move=direction)
            if cirle_x is None:
                cirle_x = 0
                circle_y = 0
            new_facing = None
            new_x = None
            new_y = None
            if direction == Direction.straight:
                if pos.facing == Facing.north:
                    new_y = pos.y - REVERSE_STRAIGHT_DISTANCE
                    new_x = pos.x

                elif pos.facing == Facing.east:
                    new_x = pos.x - REVERSE_STRAIGHT_DISTANCE
                    new_y = pos.y

                elif pos.facing == Facing.south:
                    new_y = pos.y + REVERSE_STRAIGHT_DISTANCE
                    new_x = pos.x

                elif pos.facing == Facing.west:
                    new_x = pos.x + REVERSE_STRAIGHT_DISTANCE
                    new_y = pos.y

                new_facing = pos.facing

            elif direction == Direction.right:
                if pos.facing == Facing.north:
                    new_facing = Facing.west
                    new_x = cirle_x
                    new_y = circle_y - CAR_TURNING_RADIUS

                elif pos.facing == Facing.east:
                    new_facing = Facing.north
                    new_y = circle_y
                    new_x = cirle_x - CAR_TURNING_RADIUS

                elif pos.facing == Facing.south:
                    new_facing = Facing.east
                    new_x = cirle_x
                    new_y = circle_y + CAR_TURNING_RADIUS

                elif pos.facing == Facing.west:
                    new_facing = Facing.south
                    new_y = circle_y
                    new_x = cirle_x + CAR_TURNING_RADIUS

            elif direction == Direction.left:
                if pos.facing == Facing.north:
                    new_facing = Facing.east
                    new_x = cirle_x
                    new_y = circle_y - CAR_TURNING_RADIUS

                elif pos.facing == Facing.east:
                    new_facing = Facing.south
                    new_x = cirle_x - CAR_TURNING_RADIUS
                    new_y = circle_y

                elif pos.facing == Facing.south:
                    new_facing = Facing.west
                    new_x = cirle_x
                    new_y = circle_y + CAR_TURNING_RADIUS

                elif pos.facing == Facing.west:
                    new_facing = Facing.north
                    new_x = cirle_x + CAR_TURNING_RADIUS
                    new_y = circle_y

            else:
                raise Exception("No appropriate direction")

        try:
            new_pos = Position(
                x=new_x, y=new_y, locationType=pos.locationType, facing=new_facing
            )
            # print(cirle_x, circle_y)
            cirlce_pos = Position(
                x=cirle_x, y=circle_y, locationType=LocationType.empty
            )
            return new_pos, cirlce_pos

        except Exception as e:
            print(e)
            raise e

    def _angle_between_vectors(self, v1, v2):
        v1 = np.array(v1)
        v2 = np.array(v2)

        if v1.shape[0] != 2 or v2.shape[0] != 2:
            raise ValueError("The function currently supports only 2D vectors.")

        dot_product = np.dot(v1, v2)

        mag_v1 = np.linalg.norm(v1)
        mag_v2 = np.linalg.norm(v2)

        cos_theta = dot_product / (mag_v1 * mag_v2)

        cos_theta = np.clip(cos_theta, -1.0, 1.0)

        angle_rad = np.arccos(cos_theta)

        cross_product_z = v1[0] * v2[1] - v1[1] * v2[0]

        if cross_product_z < 0:
            angle_rad = 2 * np.pi - angle_rad

        return angle_rad

    def _compute_arc_length(self, angle_rad):
        arc_length = CAR_TURNING_RADIUS * angle_rad
        return abs(arc_length)

    def _compute_arccos(self, value):
        value = np.clip(value, -1.0, 1.0)
        return np.arccos(value)

    def _rotate_vector(self, vector, radians):
        rotation_matrix = np.array(
            [[np.cos(radians), -np.sin(radians)], [np.sin(radians), np.cos(radians)]]
        )
        v_rotated = np.dot(rotation_matrix, vector)

        return v_rotated

    def _normalize_vector(self, vector):
        return vector / np.linalg.norm(vector)

    def _solve_move_safe_path(
        self, move_index: int, src: Position, dest: Position, moves_to_make: List
    ):
        move = LEGAL_MOVES[move_index]
        total_distance = math.inf

        dest_circle_x, dest_circle_y = self._get_circle_position(
            position=dest, move=move[2]
        )


        src_circle_x, src_circle_y = self._get_circle_position(
            position=src, move=move[0]
        )

        distance = math.sqrt(
            (dest_circle_x - src_circle_x) ** 2 + (dest_circle_y - src_circle_y) ** 2
        )

        if move_index == 0:  # [Direction.left, Direction.straight, Direction.left],
            v1 = np.array([dest_circle_x - src_circle_x, dest_circle_y - src_circle_y])
            v1_normal = np.array([v1[1], -v1[0]])

            v1_normal = self._normalize_vector(v1_normal)

            c1_tangent_point = (
                np.array([src_circle_x, src_circle_y]) + CAR_TURNING_RADIUS * v1_normal
            )
            c2_tangent_point = c1_tangent_point + v1
            straighline_distance, straight_line_angle_of_travel = (
                self._vector_properties(v1)
            )

            c1_to_src_vector = np.array([src.x - src_circle_x, src.y - src_circle_y])
            angle_c1 = self._angle_between_vectors(c1_to_src_vector, v1_normal)

            c2_to_dest_vector = np.array(
                [dest.x - dest_circle_x, dest.y - dest_circle_y]
            )
            angle_c2 = self._angle_between_vectors(v1_normal, c2_to_dest_vector)

            total_distance = (
                straighline_distance
                + self._compute_arc_length(angle_rad=angle_c1)
                + self._compute_arc_length(angle_rad=angle_c2)
            )

            left_turn_1 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c1),
                turning_radian=angle_c1,
                direction=Direction.left,
                start_position=src,
                end_position=Position(
                    x=c1_tangent_point[0],
                    y=c1_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                circle_center=Position(
                    x=src_circle_x, y=src_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(left_turn_1)

            straight_1 = Movement(
                distance_cm=straighline_distance,
                turning_radian=0,
                direction=Direction.straight,
                start_position=Position(
                    x=c1_tangent_point[0],
                    y=c1_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                end_position=Position(
                    x=c2_tangent_point[0],
                    y=c2_tangent_point[1],
                    locationType=LocationType.empty,
                ),
            )
            moves_to_make.append(straight_1)

            left_turn_2 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c2),
                turning_radian=angle_c2,
                direction=Direction.left,
                start_position=Position(
                    x=c2_tangent_point[0],
                    y=c2_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                end_position=dest,
                circle_center=Position(
                    x=dest_circle_x, y=dest_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(left_turn_2)

            # #print(f"""
            #       Travel total: {total_distance}
            #       1. Left by: {angle_c1}
            #       2. Straight by: {straighline_distance}
            #       3. Left by: {angle_c2}
            #       """)

        elif move_index == 1:  # [Direction.left, Direction.straight, Direction.right],
            if distance < CAR_TURNING_RADIUS * 2:
                # #print("Edge Case: Distance cannot be less than 2 * r")
                return total_distance, moves_to_make

            v1 = np.array([dest_circle_x - src_circle_x, dest_circle_y - src_circle_y])
            a_length = CAR_TURNING_RADIUS
            h_length = distance / 2
            anticlockwise_rotation_radians = -self._compute_arccos(a_length / h_length)

            c1_normal_vector = self._rotate_vector(
                vector=v1, radians=anticlockwise_rotation_radians
            )
            c1_normal_vector = self._normalize_vector(vector=c1_normal_vector)

            c1_tangent_point = (
                np.array([src_circle_x, src_circle_y])
                + CAR_TURNING_RADIUS * c1_normal_vector
            )
            c2_tangent_point = (
                np.array([dest_circle_x, dest_circle_y])
                - CAR_TURNING_RADIUS * c1_normal_vector
            )

            straight_line_vector = c2_tangent_point - c1_tangent_point
            straighline_distance, straight_line_angle_of_travel = (
                self._vector_properties(straight_line_vector)
            )

            c1_to_src_vector = np.array([src.x - src_circle_x, src.y - src_circle_y])
            angle_c1 = self._angle_between_vectors(c1_to_src_vector, c1_normal_vector)

            c2_to_dest_vector = np.array(
                [dest.x - dest_circle_x, dest.y - dest_circle_y]
            )
            angle_c2 = self._angle_between_vectors(
                c2_to_dest_vector, c1_normal_vector * -1
            )

            total_distance = (
                straighline_distance
                + self._compute_arc_length(angle_rad=angle_c1)
                + self._compute_arc_length(angle_rad=angle_c2)
            )

            left_turn_1 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c1),
                turning_radian=angle_c1,
                direction=Direction.left,
                start_position=src,
                end_position=Position(
                    x=c1_tangent_point[0],
                    y=c1_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                circle_center=Position(
                    x=src_circle_x, y=src_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(left_turn_1)

            straight_1 = Movement(
                distance_cm=straighline_distance,
                turning_radian=0,
                direction=Direction.straight,
                start_position=Position(
                    x=c1_tangent_point[0],
                    y=c1_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                end_position=Position(
                    x=c2_tangent_point[0],
                    y=c2_tangent_point[1],
                    locationType=LocationType.empty,
                ),
            )
            moves_to_make.append(straight_1)

            right_turn_1 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c2),
                turning_radian=angle_c2,
                direction=Direction.right,
                start_position=Position(
                    x=c2_tangent_point[0],
                    y=c2_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                end_position=dest,
                circle_center=Position(
                    x=dest_circle_x, y=dest_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(right_turn_1)

            # #print(f"""
            #       Travel total: {total_distance}
            #       1. Left by: {angle_c1}
            #       2. Straight by: {straighline_distance}
            #       3. Right by: {angle_c2}
            #       """)

        elif move_index == 2:
            if distance > CAR_TURNING_RADIUS * 4:
                return total_distance, moves_to_make

            v1 = np.array([dest_circle_x - src_circle_x, dest_circle_y - src_circle_y])
            a_length = distance / 2
            h_length = CAR_TURNING_RADIUS * 2
            clockwise_rotation_radians = -self._compute_arccos(a_length / h_length)

            c1_normal_vector = self._rotate_vector(
                vector=v1, radians=clockwise_rotation_radians
            )
            c1_normal_vector = self._normalize_vector(vector=c1_normal_vector)

            c3_center = (
                np.array([src_circle_x, src_circle_y])
                + 2 * CAR_TURNING_RADIUS * c1_normal_vector
            )

            c2_normal_vector = c3_center - np.array([dest_circle_x, dest_circle_y])
            c2_normal_vector = self._normalize_vector(vector=c2_normal_vector)

            c1_center_to_start = np.array([src.x - src_circle_x, src.y - src_circle_y])
            c1_center_to_end = (
                np.array([src_circle_x, src_circle_y])
                + CAR_TURNING_RADIUS * c1_normal_vector
            )
            angle_c1 = self._angle_between_vectors(
                v1=c1_center_to_start, v2=c1_normal_vector
            )

            c3_start = c1_normal_vector
            c3_end = c3_center - CAR_TURNING_RADIUS * c2_normal_vector
            angle_c3 = self._angle_between_vectors(
                v1=-c2_normal_vector, v2=-c1_normal_vector
            )

            c2_start = (
                np.array([dest_circle_x, dest_circle_y])
                + CAR_TURNING_RADIUS * c2_normal_vector
            )
            c2_center_to_end = np.array(
                [dest.x - dest_circle_x, dest.y - dest_circle_y]
            )
            angle_c2 = self._angle_between_vectors(
                v1=c2_normal_vector, v2=c2_center_to_end
            )

            total_distance = (
                self._compute_arc_length(angle_rad=angle_c1)
                + self._compute_arc_length(angle_rad=angle_c2)
                + self._compute_arc_length(angle_rad=angle_c3)
            )

            # #print(f"""
            #       Travel total: {total_distance}
            #       1. Left by: {angle_c1}
            #       2. Right by: {angle_c3}
            #       3. Left by: {angle_c2}
            #       """)

            left_turn_1 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c1),
                turning_radian=angle_c1,
                direction=Direction.left,
                start_position=src,
                end_position=Position(
                    x=c1_center_to_end[0],
                    y=c1_center_to_end[1],
                    locationType=LocationType.empty,
                ),
                circle_center=Position(
                    x=src_circle_x, y=src_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(left_turn_1)

            right_turn_1 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c3),
                turning_radian=angle_c3,
                direction=Direction.right,
                start_position=Position(
                    x=c1_center_to_end[0],
                    y=c1_center_to_end[1],
                    locationType=LocationType.empty,
                ),
                end_position=Position(
                    x=c3_end[0], y=c3_end[1], locationType=LocationType.empty
                ),
                circle_center=Position(
                    x=c3_center[0], y=c3_center[1], locationType=LocationType.empty
                ),
            )
            moves_to_make.append(right_turn_1)

            left_turn_2 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c2),
                turning_radian=angle_c2,
                direction=Direction.left,
                start_position=Position(
                    x=c3_end[0], y=c3_end[1], locationType=LocationType.empty
                ),
                end_position=dest,
                circle_center=Position(
                    x=dest_circle_x, y=dest_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(left_turn_2)

        elif move_index == 3:  # [Direction.right, Direction.straight, Direction.left],

            if distance < CAR_TURNING_RADIUS * 2:
                return total_distance, moves_to_make

            v1 = np.array([dest_circle_x - src_circle_x, dest_circle_y - src_circle_y])
            a_length = CAR_TURNING_RADIUS
            h_length = distance / 2
            anticlockwise_rotation_radians = self._compute_arccos(a_length / h_length)

            c1_normal_vector = self._rotate_vector(
                vector=v1, radians=anticlockwise_rotation_radians
            )
            c1_normal_vector = self._normalize_vector(vector=c1_normal_vector)

            c1_tangent_point = (
                np.array([src_circle_x, src_circle_y])
                + CAR_TURNING_RADIUS * c1_normal_vector
            )
            c2_tangent_point = (
                np.array([dest_circle_x, dest_circle_y])
                - CAR_TURNING_RADIUS * c1_normal_vector
            )

            straight_line_vector = c2_tangent_point - c1_tangent_point
            straighline_distance, straight_line_angle_of_travel = (
                self._vector_properties(straight_line_vector)
            )

            c1_to_src_vector = np.array([src.x - src_circle_x, src.y - src_circle_y])
            angle_c1 = self._angle_between_vectors(c1_normal_vector, c1_to_src_vector)

            c2_to_dest_vector = np.array(
                [dest.x - dest_circle_x, dest.y - dest_circle_y]
            )
            angle_c2 = self._angle_between_vectors(
                c1_normal_vector * -1, c2_to_dest_vector
            )

            total_distance = (
                straighline_distance
                + self._compute_arc_length(angle_rad=angle_c1)
                + self._compute_arc_length(angle_rad=angle_c2)
            )

            # #print(f"""
            #       Travel total: {total_distance}
            #       1. Right by: {angle_c1}
            #       2. Straight by: {straighline_distance}
            #       3. Left by: {angle_c2}
            #       """)

            right_turn_1 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c1),
                turning_radian=angle_c1,
                direction=Direction.right,
                start_position=src,
                end_position=Position(
                    x=c1_tangent_point[0],
                    y=c1_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                circle_center=Position(
                    x=src_circle_x, y=src_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(right_turn_1)

            straight_1 = Movement(
                distance_cm=straighline_distance,
                turning_radian=0,
                direction=Direction.straight,
                start_position=Position(
                    x=c1_tangent_point[0],
                    y=c1_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                end_position=Position(
                    x=c2_tangent_point[0],
                    y=c2_tangent_point[1],
                    locationType=LocationType.empty,
                ),
            )
            moves_to_make.append(straight_1)

            left_turn_1 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c2),
                turning_radian=angle_c2,
                direction=Direction.left,
                start_position=Position(
                    x=c2_tangent_point[0],
                    y=c2_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                end_position=dest,
                circle_center=Position(
                    x=dest_circle_x, y=dest_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(left_turn_1)

        elif move_index == 4:  # [Direction.right, Direction.straight, Direction.right]
            v1 = np.array([dest_circle_x - src_circle_x, dest_circle_y - src_circle_y])
            v1_normal = np.array([-v1[1], v1[0]])

            v1_normal = self._normalize_vector(vector=v1_normal)

            c1_tangent_point = (
                np.array([src_circle_x, src_circle_y]) + CAR_TURNING_RADIUS * v1_normal
            )
            c2_tangent_point = c1_tangent_point + v1
            straighline_distance, straight_line_angle_of_travel = (
                self._vector_properties(v1)
            )

            c1_to_src_vector = np.array([src.x - src_circle_x, src.y - src_circle_y])
            angle_c1 = self._angle_between_vectors(v1_normal, c1_to_src_vector)

            c2_to_dest_vector = np.array(
                [dest.x - dest_circle_x, dest.y - dest_circle_y]
            )
            angle_c2 = self._angle_between_vectors(c2_to_dest_vector, v1_normal)

            total_distance = (
                straighline_distance
                + self._compute_arc_length(angle_rad=angle_c1)
                + self._compute_arc_length(angle_rad=angle_c2)
            )

            # #print(f"""
            #       Travel total: {total_distance}
            #       1. Right by: {angle_c1}
            #       2. Straight by: {straighline_distance}
            #       3. Right by: {angle_c2}
            #       """)

            right_turn_1 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c1),
                turning_radian=angle_c1,
                direction=Direction.right,
                start_position=src,
                end_position=Position(
                    x=c1_tangent_point[0],
                    y=c1_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                circle_center=Position(
                    x=src_circle_x, y=src_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(right_turn_1)

            straight_1 = Movement(
                distance_cm=straighline_distance,
                turning_radian=0,
                direction=Direction.straight,
                start_position=Position(
                    x=c1_tangent_point[0],
                    y=c1_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                end_position=Position(
                    x=c2_tangent_point[0],
                    y=c2_tangent_point[1],
                    locationType=LocationType.empty,
                ),
            )
            moves_to_make.append(straight_1)

            right_turn_2 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c2),
                turning_radian=angle_c2,
                direction=Direction.right,
                start_position=Position(
                    x=c2_tangent_point[0],
                    y=c2_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                end_position=dest,
                circle_center=Position(
                    x=dest_circle_x, y=dest_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(right_turn_2)

        elif move_index == 5:

            if distance > CAR_TURNING_RADIUS * 4:
                return total_distance, moves_to_make
            elif distance < CAR_TURNING_RADIUS * 2:
                return total_distance, moves_to_make

            v1 = np.array([dest_circle_x - src_circle_x, dest_circle_y - src_circle_y])
            a_length = distance / 2
            h_length = CAR_TURNING_RADIUS * 2
            anticlockwise_rotation_radians = self._compute_arccos(a_length / h_length)

            c1_normal_vector = self._rotate_vector(
                vector=v1, radians=anticlockwise_rotation_radians
            )
            c1_normal_vector = self._normalize_vector(vector=c1_normal_vector)

            c3_center = (
                np.array([src_circle_x, src_circle_y])
                + 2 * CAR_TURNING_RADIUS * c1_normal_vector
            )

            c2_normal_vector = c3_center - np.array([dest_circle_x, dest_circle_y])
            c2_normal_vector = self._normalize_vector(vector=c2_normal_vector)

            c1_center_to_start = np.array([src.x - src_circle_x, src.y - src_circle_y])
            c1_end = (
                np.array([src_circle_x, src_circle_y])
                + CAR_TURNING_RADIUS * c1_normal_vector
            )
            angle_c1 = self._angle_between_vectors(
                v1=c1_normal_vector, v2=c1_center_to_start
            )

            c3_start = c1_end
            c3_end = c3_center - CAR_TURNING_RADIUS * c2_normal_vector
            angle_c3 = self._angle_between_vectors(
                v1=-c1_normal_vector, v2=-c2_normal_vector
            )

            c2_start = (
                np.array([dest_circle_x, dest_circle_y])
                + CAR_TURNING_RADIUS * c2_normal_vector
            )
            c2_center_to_end = np.array(
                [dest.x - dest_circle_x, dest.y - dest_circle_y]
            )
            angle_c2 = self._angle_between_vectors(
                v1=c2_center_to_end, v2=c2_normal_vector
            )

            total_distance = (
                self._compute_arc_length(angle_rad=angle_c1)
                + self._compute_arc_length(angle_rad=angle_c2)
                + self._compute_arc_length(angle_rad=angle_c3)
            )

            # #print(f"""
            #       Travel total: {total_distance}
            #       1. Right by: {angle_c1}
            #       2. Left by: {angle_c3}
            #       3. Right by: {angle_c2}
            #       """)

            right_turn_1 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c1),
                turning_radian=angle_c1,
                direction=Direction.right,
                start_position=src,
                end_position=Position(
                    x=c1_end[0],
                    y=c1_end[1],
                    locationType=LocationType.empty,
                ),
                circle_center=Position(
                    x=src_circle_x, y=src_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(right_turn_1)

            left_turn_1 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c3),
                turning_radian=angle_c3,
                direction=Direction.left,
                start_position=Position(
                    x=c1_end[0],
                    y=c1_end[1],
                    locationType=LocationType.empty,
                ),
                end_position=Position(
                    x=c2_start[0],
                    y=c2_start[1],
                    locationType=LocationType.empty,
                ),
                circle_center=Position(
                    x=c3_center[0], y=c3_center[1], locationType=LocationType.empty
                ),
            )
            moves_to_make.append(left_turn_1)

            right_turn_2 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c2),
                turning_radian=angle_c2,
                direction=Direction.right,
                start_position=Position(
                    x=c2_start[0],
                    y=c2_start[1],
                    locationType=LocationType.empty,
                ),
                end_position=dest,
                circle_center=Position(
                    x=dest_circle_x, y=dest_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(right_turn_2)

        elif move_index == 6:
            if distance < CAR_TURNING_RADIUS * 2:
                return total_distance, moves_to_make

            v1 = np.array([dest_circle_x - src_circle_x, dest_circle_y - src_circle_y])
            a_length = CAR_TURNING_RADIUS
            h_length = distance / 2
            anticlockwise_rotation_radians = self._compute_arccos(a_length / h_length)

            c1_normal_vector = self._rotate_vector(
                vector=v1, radians=anticlockwise_rotation_radians
            )
            c1_normal_vector = self._normalize_vector(vector=c1_normal_vector)

            c1_tangent_point = (
                    np.array([src_circle_x, src_circle_y])
                    + CAR_TURNING_RADIUS * c1_normal_vector
            )
            c2_tangent_point = (
                    np.array([dest_circle_x, dest_circle_y])
                    - CAR_TURNING_RADIUS * c1_normal_vector
            )

            straight_line_vector = c2_tangent_point - c1_tangent_point
            straighline_distance, straight_line_angle_of_travel = (
                self._vector_properties(straight_line_vector)
            )

            c1_to_src_vector = np.array([src.x - src_circle_x, src.y - src_circle_y])
            angle_c1 = 2 * math.pi - self._angle_between_vectors(c1_normal_vector, c1_to_src_vector)

            c2_to_dest_vector = np.array(
                [dest.x - dest_circle_x, dest.y - dest_circle_y]
            )
            angle_c2 = self._angle_between_vectors(
                c1_normal_vector * -1, c2_to_dest_vector
            )

            total_distance = (
                    straighline_distance
                    + self._compute_arc_length(angle_rad=angle_c1)
                    + self._compute_arc_length(angle_rad=angle_c2)
            )

            # #print(f"""
            #       Travel total: {total_distance}
            #       1. Right by: {angle_c1}
            #       2. Straight by: {straighline_distance}
            #       3. Left by: {angle_c2}
            #       """)

            right_turn_1 = Movement(
                distance_cm=-self._compute_arc_length(angle_rad=angle_c1),
                turning_radian=angle_c1,
                direction=Direction.right,
                start_position=src,
                end_position=Position(
                    x=c1_tangent_point[0],
                    y=c1_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                circle_center=Position(
                    x=src_circle_x, y=src_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(right_turn_1)

            straight_1 = Movement(
                distance_cm=straighline_distance,
                turning_radian=0,
                direction=Direction.straight,
                start_position=Position(
                    x=c1_tangent_point[0],
                    y=c1_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                end_position=Position(
                    x=c2_tangent_point[0],
                    y=c2_tangent_point[1],
                    locationType=LocationType.empty,
                ),
            )
            moves_to_make.append(straight_1)

            left_turn_1 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c2),
                turning_radian=angle_c2,
                direction=Direction.left,
                start_position=Position(
                    x=c2_tangent_point[0],
                    y=c2_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                end_position=dest,
                circle_center=Position(
                    x=dest_circle_x, y=dest_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(left_turn_1)
        elif move_index == 7:
            v1 = np.array([dest_circle_x - src_circle_x, dest_circle_y - src_circle_y])
            v1_normal = np.array([-v1[1], v1[0]])

            v1_normal = self._normalize_vector(vector=v1_normal)

            c1_tangent_point = (
                    np.array([src_circle_x, src_circle_y]) + CAR_TURNING_RADIUS * v1_normal
            )
            c2_tangent_point = c1_tangent_point + v1
            straighline_distance, straight_line_angle_of_travel = (
                self._vector_properties(v1)
            )

            c1_to_src_vector = np.array([src.x - src_circle_x, src.y - src_circle_y])
            angle_c1 = 2 * math.pi - self._angle_between_vectors(v1_normal, c1_to_src_vector)

            c2_to_dest_vector = np.array(
                [dest.x - dest_circle_x, dest.y - dest_circle_y]
            )
            angle_c2 = self._angle_between_vectors(c2_to_dest_vector, v1_normal)

            total_distance = (
                    straighline_distance
                    + self._compute_arc_length(angle_rad=angle_c1)
                    + self._compute_arc_length(angle_rad=angle_c2)
            )

            # #print(f"""
            #       Travel total: {total_distance}
            #       1. Right by: {angle_c1}
            #       2. Straight by: {straighline_distance}
            #       3. Right by: {angle_c2}
            #       """)

            right_turn_1 = Movement(
                distance_cm=-self._compute_arc_length(angle_rad=angle_c1),
                turning_radian=angle_c1,
                direction=Direction.right,
                start_position=src,
                end_position=Position(
                    x=c1_tangent_point[0],
                    y=c1_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                circle_center=Position(
                    x=src_circle_x, y=src_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(right_turn_1)

            straight_1 = Movement(
                distance_cm=straighline_distance,
                turning_radian=0,
                direction=Direction.straight,
                start_position=Position(
                    x=c1_tangent_point[0],
                    y=c1_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                end_position=Position(
                    x=c2_tangent_point[0],
                    y=c2_tangent_point[1],
                    locationType=LocationType.empty,
                ),
            )
            moves_to_make.append(straight_1)

            right_turn_2 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c2),
                turning_radian=angle_c2,
                direction=Direction.right,
                start_position=Position(
                    x=c2_tangent_point[0],
                    y=c2_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                end_position=dest,
                circle_center=Position(
                    x=dest_circle_x, y=dest_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(right_turn_2)
        elif move_index == 8:
            v1 = np.array([dest_circle_x - src_circle_x, dest_circle_y - src_circle_y])
            v1_normal = np.array([v1[1], -v1[0]])

            v1_normal = self._normalize_vector(v1_normal)

            c1_tangent_point = (
                    np.array([src_circle_x, src_circle_y]) + CAR_TURNING_RADIUS * v1_normal
            )
            c2_tangent_point = c1_tangent_point + v1
            straighline_distance, straight_line_angle_of_travel = (
                self._vector_properties(v1)
            )

            c1_to_src_vector = np.array([src.x - src_circle_x, src.y - src_circle_y])
            angle_c1 = 2 * math.pi - self._angle_between_vectors(c1_to_src_vector, v1_normal)

            c2_to_dest_vector = np.array(
                [dest.x - dest_circle_x, dest.y - dest_circle_y]
            )
            angle_c2 = self._angle_between_vectors(v1_normal, c2_to_dest_vector)

            total_distance = (
                    straighline_distance
                    + self._compute_arc_length(angle_rad=angle_c1)
                    + self._compute_arc_length(angle_rad=angle_c2)
            )

            left_turn_1 = Movement(
                distance_cm=-self._compute_arc_length(angle_rad=angle_c1),
                turning_radian=angle_c1,
                direction=Direction.left,
                start_position=src,
                end_position=Position(
                    x=c1_tangent_point[0],
                    y=c1_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                circle_center=Position(
                    x=src_circle_x, y=src_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(left_turn_1)

            straight_1 = Movement(
                distance_cm=straighline_distance,
                turning_radian=0,
                direction=Direction.straight,
                start_position=Position(
                    x=c1_tangent_point[0],
                    y=c1_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                end_position=Position(
                    x=c2_tangent_point[0],
                    y=c2_tangent_point[1],
                    locationType=LocationType.empty,
                ),
            )
            moves_to_make.append(straight_1)

            left_turn_2 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c2),
                turning_radian=angle_c2,
                direction=Direction.left,
                start_position=Position(
                    x=c2_tangent_point[0],
                    y=c2_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                end_position=dest,
                circle_center=Position(
                    x=dest_circle_x, y=dest_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(left_turn_2)
        elif move_index == 9:
            if distance < CAR_TURNING_RADIUS * 2:
                # #print("Edge Case: Distance cannot be less than 2 * r")
                return total_distance, moves_to_make

            v1 = np.array([dest_circle_x - src_circle_x, dest_circle_y - src_circle_y])
            a_length = CAR_TURNING_RADIUS
            h_length = distance / 2
            anticlockwise_rotation_radians = -self._compute_arccos(a_length / h_length)

            c1_normal_vector = self._rotate_vector(
                vector=v1, radians=anticlockwise_rotation_radians
            )
            c1_normal_vector = self._normalize_vector(vector=c1_normal_vector)

            c1_tangent_point = (
                np.array([src_circle_x, src_circle_y])
                + CAR_TURNING_RADIUS * c1_normal_vector
            )
            c2_tangent_point = (
                np.array([dest_circle_x, dest_circle_y])
                - CAR_TURNING_RADIUS * c1_normal_vector
            )

            straight_line_vector = c2_tangent_point - c1_tangent_point
            straighline_distance, straight_line_angle_of_travel = (
                self._vector_properties(straight_line_vector)
            )

            c1_to_src_vector = np.array([src.x - src_circle_x, src.y - src_circle_y])
            angle_c1 = 2 * math.pi -  self._angle_between_vectors(c1_to_src_vector, c1_normal_vector)

            c2_to_dest_vector = np.array(
                [dest.x - dest_circle_x, dest.y - dest_circle_y]
            )
            angle_c2 = self._angle_between_vectors(
                c2_to_dest_vector, c1_normal_vector * -1
            )

            total_distance = (
                straighline_distance
                + self._compute_arc_length(angle_rad=angle_c1)
                + self._compute_arc_length(angle_rad=angle_c2)
            )

            left_turn_1 = Movement(
                distance_cm=-self._compute_arc_length(angle_rad=angle_c1),
                turning_radian=angle_c1,
                direction=Direction.left,
                start_position=src,
                end_position=Position(
                    x=c1_tangent_point[0],
                    y=c1_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                circle_center=Position(
                    x=src_circle_x, y=src_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(left_turn_1)

            straight_1 = Movement(
                distance_cm=straighline_distance,
                turning_radian=0,
                direction=Direction.straight,
                start_position=Position(
                    x=c1_tangent_point[0],
                    y=c1_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                end_position=Position(
                    x=c2_tangent_point[0],
                    y=c2_tangent_point[1],
                    locationType=LocationType.empty,
                ),
            )
            moves_to_make.append(straight_1)

            right_turn_1 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c2),
                turning_radian=angle_c2,
                direction=Direction.right,
                start_position=Position(
                    x=c2_tangent_point[0],
                    y=c2_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                end_position=dest,
                circle_center=Position(
                    x=dest_circle_x, y=dest_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(right_turn_1)
        # #print(f"{move_index=}")
        if self.is_safe_movement(moves_to_make) == False:
            total_distance = math.inf
        return total_distance, moves_to_make

    def _map_obstacle_to_actual_location(self, pos: Position):
        # x = (pos.x + 0.5) * GRID_SIZE
        # y = (pos.y + 0.5) * GRID_SIZE
        if pos.facing == Facing.east:
            x = (pos.x + 0.5) * GRID_SIZE - self.landing_supplement
            y = (pos.y + 0.5) * GRID_SIZE
        elif pos.facing == Facing.north:
            x = (pos.x + 0.5) * GRID_SIZE
            y = (pos.y+ 0.5) * GRID_SIZE - self.landing_supplement
        elif pos.facing == Facing.south:
            x = (pos.x + 0.5) * GRID_SIZE
            y = (pos.y + 0.5) * GRID_SIZE + self.landing_supplement
        elif pos.facing == Facing.west:
            x = (pos.x + 0.5) * GRID_SIZE + self.landing_supplement
            y = (pos.y + 0.5) * GRID_SIZE
        new_pos = Position(
            x=x,
            y=y,
            locationType=pos.locationType,
            facing=pos.facing,
        )
        return new_pos

    def _plan_landing_zones(self):
        for y in range(GRID_COUNT):
            for x in range(GRID_COUNT):
                position = self.game.arena[y][x]
                if position.locationType == LocationType.obstacle:

                    if position.facing == Facing.east:
                        self.game.arena[y][
                            x + LANDING_DISTANCE
                        ].locationType = LocationType.landing
                        self.game.arena[y][x + LANDING_DISTANCE].facing = Facing.west
                        self.game.arena[y][
                            x + LANDING_DISTANCE
                        ].result = position.result
                        self.game.arena[y][
                            x + LANDING_DISTANCE
                            ].id = position.id

                        new_goal = self._map_obstacle_to_actual_location(
                                self.game.arena[y][x + LANDING_DISTANCE]
                            )



                    elif position.facing == Facing.north:

                        self.game.arena[y + LANDING_DISTANCE][
                            x
                        ].locationType = LocationType.landing
                        self.game.arena[y + LANDING_DISTANCE][x].facing = Facing.south
                        self.game.arena[y + LANDING_DISTANCE][
                            x
                        ].result = position.result
                        self.game.arena[y + LANDING_DISTANCE][
                            x
                        ].id = position.id

                        new_goal=    self._map_obstacle_to_actual_location(
                                self.game.arena[y + LANDING_DISTANCE][x]
                            )


                    elif position.facing == Facing.west:

                        self.game.arena[y][
                            x - LANDING_DISTANCE
                        ].locationType = LocationType.landing
                        self.game.arena[y][x - LANDING_DISTANCE].facing = Facing.east
                        self.game.arena[y][
                            x - LANDING_DISTANCE
                        ].result = position.result
                        self.game.arena[y][
                            x - LANDING_DISTANCE
                            ].id = position.id
                        new_goal = self._map_obstacle_to_actual_location(
                                self.game.arena[y][x - LANDING_DISTANCE]
                            )


                    else:

                        self.game.arena[y - LANDING_DISTANCE][
                            x
                        ].locationType = LocationType.landing
                        self.game.arena[y - LANDING_DISTANCE][x].facing = Facing.north
                        self.game.arena[y - LANDING_DISTANCE][
                            x
                        ].result = position.result
                        self.game.arena[y - LANDING_DISTANCE][
                            x
                        ].id = position.id
                        new_goal = self._map_obstacle_to_actual_location(
                                self.game.arena[y - LANDING_DISTANCE][x]
                            )


                    self.goals.append(
                        new_goal
                    )
                    self.goals_to_id_mapping[len(self.goals_to_id_mapping.keys())] = position.id


        self.shortest_distance_matrix = [
            [math.inf for b in range(len(self.goals) + 1)]
            for a in range(len(self.goals) + 1)
        ]
        print(self.goals)
    # def _get_source_cirle_position(self, position: Position):

    def _get_circle_position(self, position: Position, move: Direction):
        x = position.x
        y = position.y
        if position.facing == Facing.east:
            if move == Direction.left or move == Direction.reverse_left:
                return x, y + CAR_TURNING_RADIUS
            elif move == Direction.right or move == Direction.reverse_right:
                return x, y - CAR_TURNING_RADIUS
        elif position.facing == Facing.north:
            if move == Direction.left or move == Direction.reverse_left:
                return x - CAR_TURNING_RADIUS, y
            elif move == Direction.right or move == Direction.reverse_right:
                return x + CAR_TURNING_RADIUS, y
        elif position.facing == Facing.west:
            if move == Direction.left or move == Direction.reverse_left:
                return x, y - CAR_TURNING_RADIUS
            elif move == Direction.right or move == Direction.reverse_right:
                return x, y + CAR_TURNING_RADIUS
        elif position.facing == Facing.south:
            if move == Direction.left or move == Direction.reverse_left:
                return x + CAR_TURNING_RADIUS, y
            elif move == Direction.right or move == Direction.reverse_right:
                return x - CAR_TURNING_RADIUS, y

        # #print(f"Error when getting circle position for {position} direction: {move}")
        return None, None

    def _let_salesman_travel(self):

        def is_home(pos: Position):
            return pos.x == CAR_X_START_POS and pos.y == CAR_Y_START_POS

        def recursion(
            obstacles_explored: List[int],
            total_cost_incurred: float,
            current_obstacle_id: int,
            moves: List[int],
        ):
            copy_moves = moves[:]
            copy_moves.append(current_obstacle_id)

            if len(obstacles_explored) == len(self.goals) - 1:
                # moves.append(len(self.shortest_distance_matrix) - 1)
                return (
                    total_cost_incurred,
                    copy_moves,
                )

            shortest_distance = math.inf
            min_moves = None

            for index in range(len(self.goals)):

                # if is_home(pos=obstacle):
                #     continue

                if (
                    index == len(self.goals) - 1 or index in obstacles_explored
                ):  ## Home or obstacle has already been explored
                    continue

                copy_obstacles_explored = obstacles_explored[:]
                copy_obstacles_explored.append(index)
                copy_distance = (
                    total_cost_incurred
                    + self.shortest_distance_matrix[current_obstacle_id][index].distance
                )
                working_distance, working_moves = recursion(
                    obstacles_explored=copy_obstacles_explored,
                    total_cost_incurred=copy_distance,
                    current_obstacle_id=index,
                    moves=copy_moves,
                )

                if working_distance < shortest_distance:
                    shortest_distance = working_distance
                    min_moves = working_moves

                # if len(obstacles_explored) == 0:
                #     print(f"Distance: {working_distance} Series: {working_moves}")

            return shortest_distance, min_moves

        shortest_distance, min_moves = recursion(
            obstacles_explored=[],
            total_cost_incurred=0,
            current_obstacle_id=len(self.goals) - 1,
            moves=[],
        )
        # print(shortest_distance, min_moves)

        if min_moves is None:
            # self.sale_path = None
            # self.go
            # self.game = None
            self._initialize()
            return

        movement_seq = []
        movement_string = []
        for src_index in range(len(min_moves) - 1):
            dest_index = (src_index + 1) % len(min_moves)
            y = min_moves[src_index]
            x = min_moves[dest_index]


            movement_seq += self.shortest_distance_matrix[y][x].movements_to_take
            movement_string += self.convert_to_command(self.shortest_distance_matrix[y][x].movements_to_take, self.goals_to_id_mapping[x])
            # movement_seq.append(
            #     Movement(
            #         distance_cm=0,
            #         turning_radian=0,
            #         direction=Direction.straight,
            #         start_position=Position(
            #             x=-1, y=-1, locationType=LocationType.empty
            #         ),
            #         end_position=Position(x=-1, y=-1, locationType=LocationType.empty),
            #     )
            # )
        # print(self.convert_to_command(movement_seq))

        self.sale_path = TravelledSalesman(
            total_distance=shortest_distance,
            obstacle_seq=min_moves,
            movement_path=movement_seq,
            movement_string=movement_string,
        )
        # self.string_solution = self.convert_to_command(movement_seq)

    def convert_to_array(self, val):
        return np.array([val.x, val.y], dtype=int)
    def closest_distance(self, start1, end1, start2, end2):

        p1 = self.convert_to_array(start1)
        p2 = self.convert_to_array(end1)
        p3 = self.convert_to_array(start2)
        p4 = self.convert_to_array(end2)

        d1 = p2 - p1  # Direction vector of line segment 1
        d2 = p4 - p3  # Direction vector of line segment 2
        r = p1 - p3

        a = np.dot(d1, d1)  # Length squared of segment 1
        b = np.dot(d1, d2)  # Dot product of the direction vectors
        c = np.dot(d2, d2)  # Length squared of segment 2
        e = np.dot(r, d1)  # Projection of r onto d1
        f = np.dot(r, d2)  # Projection of r onto d2

        # Solve for s and t
        denominator = a * c - b * b
        if denominator == 0:  # Parallel lines
            # Handle parallel case by finding distance to endpoints
            return np.min([
                np.linalg.norm(p1 - p3),
                np.linalg.norm(p1 - p4),
                np.linalg.norm(p2 - p3),
                np.linalg.norm(p2 - p4),
            ])

        # Calculate parameter values for the closest points
        s_numer = b * f - c * e
        t_numer = a * f - b * e

        s = s_numer / denominator
        t = t_numer / denominator

        # Check if the segments intersect
        if 0 <= s <= 1 and 0 <= t <= 1:
            return 0.0  # Segments intersect

        # Clamp the values of s and t to the range [0, 1]
        s = np.clip(s, 0, 1)
        t = np.clip(t, 0, 1)

        # Calculate the closest points
        closest_point1 = p1 + s * d1
        closest_point2 = p3 + t * d2

        # Return the distance between the closest points
        return np.linalg.norm(closest_point1 - closest_point2)

    def closest_distance_point_to_line(self, start, end, point):
        p1 = self.convert_to_array(start)
        p2 = self.convert_to_array(end)
        p = np.array([point.x * GRID_SIZE + GRID_SIZE // 2, point.y * GRID_SIZE + GRID_SIZE // 2], dtype=int)
        line_vector = p2 - p1  # Direction vector of the line segment
        point_vector = p - p1  # Vector from the start of the line segment to the point

        line_length_squared = np.dot(line_vector, line_vector)

        if line_length_squared == 0:  # The segment is just a point
            return np.linalg.norm(p - p1)

        # Projection factor
        t = np.dot(point_vector, line_vector) / line_length_squared
        t = np.clip(t, 0, 1)  # Clamp to the range [0, 1]

        # Find the closest point on the line segment
        closest_point = p1 + t * line_vector

        # Return the distance from the point to the closest point on the segment
        return np.linalg.norm(p - closest_point)

    def check_straight_movement(self, movement: Movement):
        start = movement.start_position
        end = movement.end_position


        for edge in self.edges:
            distance = self.closest_distance(start, end, edge[0], edge[1])
            if distance < self.safety_distance_edge:
                return False

        for obstacle in self.obstacle:
            distance = self.closest_distance_point_to_line(start, end, obstacle)
            if distance < self.safety_distance_obstacle:
                return False
        return True

    def check_turn_movement(self, movement: Movement):
        def calculate_angle(p1, p2):
            p1 = self.convert_to_array(p1)
            p2 = self.convert_to_array(p2)
            delta_x = p2[0] - p1[0]
            delta_y = p2[1] - p1[1]
            angle = np.arctan2(delta_y, delta_x)
            if angle < 0:
                angle += 2 * np.pi

            return angle

        def calculate_distance(p1, p2):
            p1 = self.convert_to_array(p1)
            p2 = self.convert_to_array(p2)

            distance = np.linalg.norm(p2 - p1)

            return distance

        def closest_point_on_segment(point, start, end):
            point = self.convert_to_array(point)
            start =  self.convert_to_array(start)
            end =  self.convert_to_array(end)
            segment = end - start
            segment_length_squared = np.dot(segment, segment)
            if segment_length_squared == 0:
                return start
            t = np.dot(point - start, segment) / segment_length_squared
            t = np.clip(t, 0, 1)
            closest_point = start + t * segment

            return closest_point

        def modulo_angle(angle):
            return angle % (2 * np.pi)

        for obstacle in self.obstacle:
            pos = Position(x=obstacle.x * GRID_SIZE + GRID_SIZE // 2, y=obstacle.y * GRID_SIZE + GRID_SIZE // 2, locationType=LocationType.empty)
            angle = calculate_angle(movement.circle_center, pos)
            start_angle = calculate_angle(movement.circle_center, movement.start_position)
            end_angle = calculate_angle(movement.circle_center, movement.end_position)

            if (movement.direction == Direction.left and movement.distance_cm > 0) or (movement.direction == Direction.right and movement.distance_cm <= 0):

                start_angle = modulo_angle(start_angle - ANGLE_SUPPLEMENT)
                end_angle = modulo_angle(end_angle + ANGLE_SUPPLEMENT)

                # if movement.start_position.x >= 77 and movement.start_position.x <= 78 and obstacle.id == 2:
                #     print(movement.circle_center, movement.start_position)
                #     print(movement.circle_center, movement.end_position)
                #     print(pos)
                #     print(f"Distance: {movement.distance_cm} cm")
                #     print(f"Start angle: {start_angle}")
                #     print(f"End angle: {end_angle}")
                #     print(angle)
                #     print((start_angle < end_angle and angle >= start_angle and angle <= end_angle) or (start_angle > end_angle and (angle >= start_angle or angle <= end_angle)))
                if (start_angle < end_angle and angle >= start_angle and angle <= end_angle) or (start_angle > end_angle and (angle >= start_angle or angle <= end_angle)):
                    distance = calculate_distance(movement.circle_center, pos)
                    if distance < self.safety_distance_turning_obstacle:
                        return False

            elif (movement.direction == Direction.right and movement.distance_cm > 0) or (movement.direction == Direction.left and movement.distance_cm <= 0):
                start_angle = modulo_angle(start_angle + ANGLE_SUPPLEMENT)
                end_angle = modulo_angle(end_angle - ANGLE_SUPPLEMENT)
                # print(angle,start_angle, end_angle)
                if (start_angle > end_angle and angle <= start_angle and angle >= end_angle) or (start_angle < end_angle and (angle <= start_angle or angle >= end_angle)):
                    distance = calculate_distance(movement.circle_center, pos)
                    # print(f"Distance: {distance}")
                    if distance < self.safety_distance_turning_obstacle:
                        return False

        # COMMENT THIS OUT IF CRASH
        if self.check_edge:
            for edge in self.edges:
                closest_point = closest_point_on_segment(movement.circle_center, edge[0], edge[1])
                closest_point = Position(x=closest_point[0], y=closest_point[1], locationType=LocationType.empty)
                distance = calculate_distance(closest_point, movement.circle_center)
                if distance < self.safety_distance_turning_edge:
                    return False



        return True
    def is_safe_movement(self, moves_to_make: List[Movement]):
        for move in moves_to_make:
            try:
                if move is None:
                    return False
                # print(f"{move=}")
                if move.start_position.x == CAR_X_START_POS and move.start_position.y == CAR_Y_START_POS:
                    continue
                if move.turning_radian != 0:
                    # print(f"Handling turn: {move}")
                    if self.check_turn_movement(move) is False:
                        return False
                if move.turning_radian == 0:
                    # print(f"Handle straight: {move}")
                    if self.check_straight_movement(move) is False:
                        return False
            except:
                return False
        return True


    def convert_to_command(self, movement_seq, dest):
        command_dict = {
            "straight": "S",
            "right": "R",
            "left": "L",
            "forward": "F",
            "backward": "B",
            "reset": "G",
        }

        def calculate_degree(distance):
            radian = distance / CAR_TURNING_RADIUS
            degree = radian * (180 / math.pi)
            return degree

        command_list = [f"{MOVING_TAG}{dest}"]

        for move in movement_seq:

            position_update = {}
            position_update["car_position"] = {"x": move.end_position.x,
                                               "y": move.end_position.y,
                                               "dir": move.end_position.facing.value}
            if move.distance_cm == 0:
                continue

            if move.start_position.x == -1:
                command = "G"
            else:
                distance = move.distance_cm
                backwards = False
                if distance < 0:
                    backwards = True
                    distance = -distance

                direction = move.direction
                if direction == Direction.right:
                    degree = calculate_degree(distance)
                    formatted_degree = f"{int(degree):03d}"
                    command = "R" + formatted_degree
                elif direction == Direction.straight:
                    formatted_distance = f"{int(distance):03d}"
                    command = "S" + formatted_distance
                elif direction == Direction.left:
                    degree = calculate_degree(distance)
                    formatted_degree = f"{int(degree):03d}"
                    command = "L" + formatted_degree

                if backwards:
                    command = command[:1] + "B" + command[1:]
                else:
                    command = command[:1] + "F" + command[1:]
            position_update['command'] = command
            command_list.append(position_update)

        command_list.append("--scan image--")

        
        return command_list







--------------------------------------------------------------------------------
File: ObjectTypes/__init__.py

--------------------------------------------------------------------------------
File: ObjectTypes/object_types.py
from pydantic import BaseModel
from enum import Enum
from typing import List, Optional

# from PathFinding_task2.constants import TASK2_CAR_START_X, TASK2_CAR_START_Y


class Facing(Enum):
    east = 0
    north = 1
    west = 2
    south = 3


class LocationType(Enum):
    empty = 0
    obstacle = 1
    landing = 2
    landing_cleared = 3
    landing_padding = 4
    parking_barrier = 5


class Position(BaseModel):
    x: float
    y: float
    locationType: LocationType
    facing: Facing = Facing.north
    result: Optional[str] = "No result"
    id: Optional[int] = -1


class Direction(Enum):
    right = 1
    straight = 2
    left = 3
    reverse = 4
    reverse_right = 5
    reverse_left = 6


class Vector(BaseModel):
    x: float
    y: float


class Movement(BaseModel):
    distance_cm: float
    turning_radian: float
    direction: Direction
    start_position: Position 
    end_position: Position 
    circle_center: Optional[Position] = None


class MinimumPath(BaseModel):
    distance: float
    movements_to_take: List[Movement]


class Car(BaseModel):
    current_position: Position
    facing_radian: float


class GameObstacleScanning(BaseModel):
    obstacle_position: Position
    # path: List[Movement] = None
    car: Car
    landing_positions: List[Position] = None
    solution: List[MinimumPath] = []
    solution_str: List[str] = "No solution"

class GameTask1(BaseModel):
    arena: List[List[Position]]
    # path: List[Movement] = None
    car: Car
    solution: List[MinimumPath] = []

class TravelledSalesman(BaseModel):
    total_distance: float
    obstacle_seq: List[int]
    movement_path: List[Movement]
    movement_string: List[str]


class WebsocketMessageType(Enum):
    change_mode = 1
    obstacle_result = 2
    reached_obstacle = 3
    stm_instr_set = 4
    obstacle_positions = 5
    ultrasonic_dist = 6

class WebsocketMessage(BaseModel):
    message_type: WebsocketMessageType
    value: str


class SessionMode(Enum):
    task1 = 0
    task2 = 1
    obstacle_scanning = 2


class Task2Progress(Enum):
    car_initial_parked = 0
    next_to_obstacle_1 = 1
    next_to_obstacle_1_on_return = 2
    parking_car = 4


class ArrowDirection(Enum):
    left = 1
    right = 2
    none = 3

# class GameTask2(BaseModel):
#     obstacle_1_landing: Optional[Position] = None
#     obstacle_1: Optional[Position] = None
#     car_start_location: Position = Position(x=TASK2_CAR_START_X, y=TASK2_CAR_START_Y, locationType = LocationType.landing)

--------------------------------------------------------------------------------
File: ComputerServer/__init__.py

--------------------------------------------------------------------------------
File: ComputerServer/data_manager.py
from ObjectTypes.object_types import *
import math
import random
import asyncio
from queue import Queue
from collections import deque
from fastapi import BackgroundTasks
import time
import json
import os
import cv2
import numpy as np
from PathFinding_task1.game_solver import GameSolverTask1
from PathFinding_task1.visualiser import Visualiser
from PathFinding_task1.constants import *
from PathFinding_task2.constants import RCHED_LOC_TAG


def stitch_images(folder_path='./result_pics', output_name='STITCHED', images_per_row=3):
    images = []

    # Load all images from the specified folder
    for filename in os.listdir(folder_path):
        if filename.split('.')[0] == output_name:
            continue
        if filename.endswith(('.png', '.jpg', '.jpeg', '.bmp', '.gif')):
            img_path = os.path.join(folder_path, filename)
            img = cv2.imread(img_path)
            if img is not None:
                images.append(img)

    if not images:
        print("No images found in the specified folder.")
        return

    # Calculate grid dimensions
    num_images = len(images)
    if num_images < images_per_row:
        images_per_row = num_images
    rows = math.ceil(num_images / images_per_row)

    # Resize images to the same size (optional, but recommended for a grid)
    # height, width, _ = images[0].shape
    # resized_images = [cv2.resize(img, (width, height)) for img in images]

    # Create a blank canvas for the grid
    stitched_image = []

    # Create a blank image for padding
    padding_image = np.zeros(images[0].shape, dtype=np.uint8)

    for i in range(rows):
        row_images = images[i * images_per_row:(i + 1) * images_per_row]

        # Pad the last row if it has fewer images
        while len(row_images) < images_per_row:
            row_images.append(padding_image)

        stitched_row = cv2.hconcat(row_images)
        stitched_image.append(stitched_row)

    # Concatenate all rows vertically
    final_stitched_image = cv2.vconcat(stitched_image)

    # Save the stitched image
    output_image_path = os.path.join(folder_path, output_name + '.jpg')
    cv2.imwrite(output_image_path, final_stitched_image)
    print(f"[PC] DATA_MANAGER.PY: Stitched image saved at: {output_image_path}")

    return


class DataManager:
    def __init__(self):
        self.visualiser = Visualiser()
        self.gametask1 = None
        self.gameobstaclescanning = None
        self.gameobstaclescanning_index = 0
        self.session_mode = None
        self.create_empty_gameobstaclescanning()
        self.websocket_manager = None
        self.image_id_queue = deque([], maxlen=5)
        self.counter = []
        self.task1_string_solution = None
        self.task1_index = 0
        self.sale_path = None
        self.obstacle_index = 0
        self.task1_target_id = None
        self.prev_image_update = None

        self.task2_manager = None
        self.task2_queue = []
        self.task2progress = Task2Progress.car_initial_parked
        self.obstacle1_distance_from_parking = None
        self.obstacle2_distance_from_obstacle1 = None
        self.obstacle2_width = None
        self.obstacle1_arrow = ArrowDirection.none
        self.obstacle2_arrow = ArrowDirection.none
        self.car_asked_for_next_move = False

    def set_websocket_manager(self, websocket_manager):
        self.websocket_manager = websocket_manager

    def check_if_all_same(self):
        target = None

        # print(self.image_id_queue)
        if len(self.image_id_queue) != 5:
            return False

        for item in self.image_id_queue:
            if target is None:
                target = item
            elif target != item:
                return False
        return True

    def create_empty_gameobstaclescanning(self):
        car = Car(
            current_position=Position(
                y=10,
                x=100,
                locationType=LocationType.empty,
                facing=Facing.north,
                result="Home",
            ),
            facing_radian=math.pi / 2,
        )
        obstacle_pos = Position(
            x=0,
            y=0,
            locationType=LocationType.obstacle,
            facing=Facing(value=random.randint(0, 3)),
            result="None",
        )
        self.gameobstaclescanning = GameObstacleScanning(
            obstacle_position=obstacle_pos, car=car
        )

    def update_mode(self, new_mode: SessionMode):
        print(f"Data Manager mode: {new_mode}")
        self.session_mode = new_mode
        if self.session_mode == SessionMode.task2:
            self.send_message_sync(str('TTTTT'), WebsocketMessageType.stm_instr_set)

    def update_id(self, image_id):
        if self.session_mode is None:
            raise Exception("Session mode not set")
        elif self.session_mode == SessionMode.obstacle_scanning:

            self.image_id_queue.append(image_id)

            if self.check_if_all_same():
                print(f"ID has been updated {image_id}")
                self.gameobstaclescanning.obstacle_position.result = str(image_id)
                return True

        elif self.session_mode == SessionMode.task1:
            if self.task1_target_id is None:
                print(f"[PC] DATA_MANAGER.PY: Inferred {image_id} but no target id")
                return False

            self.image_id_queue.append(image_id)

            if not self.check_if_all_same():
                # print(self.image_id_queue)
                return False

            for row in self.gametask1.arena:
                for pos in row:
                    if pos.id == self.task1_target_id:
                        pos.result = str(image_id)
                        # print(f"Updated {pos.id} to {image_id}")
                        temp = f'{pos.id}->{image_id}'
                        if self.prev_image_update == temp:
                            pass
                        else:
                            self.prev_image_update = temp
                            self.send_message_sync(f"{pos.id}->{image_id}", WebsocketMessageType.obstacle_result)
                        return True

        elif self.session_mode == SessionMode.task2:
            self.image_id_queue.append(image_id)
            if self.check_if_all_same():
                return True
        return False

    async def send_message_async(self, res_str, message_type):
        # from ComputerServer.initializer import websocket_manager
        print("[PC to RPI] Websocket Sending: ", res_str)
        message = WebsocketMessage(message_type=message_type, value=str(res_str))
        if self.websocket_manager is None:
            print("Websocket is None")
            return
        await self.websocket_manager.send_message(message=message)

    def send_message_sync(self, res_str, message_type):
        try:
            loop = asyncio.get_event_loop()
            loop_bool = loop.is_running()
        except:
            # print("[PC] DATA_MANAGER.PY: loop failed")
            loop_bool = False
            pass
        if loop_bool:
            loop.create_task(self.send_message_async(res_str, message_type))
        else:
            asyncio.run(self.send_message_async(res_str, message_type))

    def update_obstaclescanning_reached_obstacle(self, fromRPI=False):
        if self.session_mode == SessionMode.obstacle_scanning:
            if (
                self.gameobstaclescanning_index
                >= len(self.gameobstaclescanning.solution_str)
                or self.gameobstaclescanning.obstacle_position.result != "No result"
            ):
                print(self.gameobstaclescanning.obstacle_position.result)
                self.gameobstaclescanning_index = 0
                return
            res = self.gameobstaclescanning.solution_str[
                self.gameobstaclescanning_index
            ]
            self.gameobstaclescanning_index += 1
            self.send_message_sync(res, WebsocketMessageType.stm_instr_set)

        elif self.session_mode == SessionMode.task1:
            # if len(self.task1_string_solution) - 1== 0:
            #     stitch_images('./result_pics/task1')

            if self.task1_index >= len(self.task1_string_solution):
                print("[PC] DATA_MANAGER.PY: Done With Task 1")
                self.task1_index = 0
                stitch_images('./result_pics/task1')
                return

            res = str(self.task1_string_solution[self.task1_index])
            if res.startswith(MOVING_TAG):
                if self.task1_index != 0:
                    time.sleep(2)
                self.task1_target_id = int(res.strip(MOVING_TAG))
                self.image_id_queue.clear()
                self.task1_index += 1
                res = str(self.task1_string_solution[self.task1_index])
            self.task1_index += 1
            self.send_message_sync(res, WebsocketMessageType.stm_instr_set)
        # return res

        elif self.session_mode == SessionMode.task2:
            if len(self.task2_queue) > 0 and self.task2_queue[0].startswith(RCHED_LOC_TAG):
                status = self.task2_queue.pop(0).strip(RCHED_LOC_TAG)
                self.task2progress = Task2Progress(value=int(status))
                # if self.task2progress == Task2Progress.next_to_obstacle_1:
                #     self.send_message_sync("TTTTT", WebsocketMessageType.stm_instr_set)
                #     pass
                if self.task2progress == Task2Progress.parking_car:
                    stitch_images('./result_pics/task2')
            # while len(self.task2_queue) == 0:
            #     pass

            if len(self.task2_queue) <= 0:
                self.car_asked_for_next_move = True
                return
            res = self.task2_queue.pop(0)

            message = str({'command': res}).replace("'", '"')
            self.send_message_sync(message, WebsocketMessageType.stm_instr_set)

    def handle_ultrasonic(self, dist):
        if 'r' in dist:
            return
        dist = int(dist)
        if self.obstacle1_distance_from_parking is None:
            self.obstacle1_distance_from_parking = dist
        else:
            self.obstacle2_distance_from_obstacle1 = dist

        self.task2_manager.update_path()

    def add_task2_move(self, move: str):
        if len(self.task2_queue) > 0:
            last_item = self.task2_queue[-1]
            if last_item[:2] == move[:2]:
                distance = int(last_item[-3:]) + int(move[-3:])
                # if distance < 100:
                #     distance = f"0{distance}"
                last_item = f"{self.task2_queue[-1][:2]}{distance:03}"
                self.task2_queue[-1] = last_item
                return
        self.task2_queue.append(move)
        if self.car_asked_for_next_move:
            self.car_asked_for_next_move = False
            self.update_obstaclescanning_reached_obstacle()

    def create_game(self, obstacle_positions: str):
        self.session_mode = SessionMode.task1
        print(obstacle_positions)
        obstacle_positions = obstacle_positions.replace("'", '"')
        data = json.loads(obstacle_positions)
        positions = []
        car = Car(
            current_position=Position(
                y=CAR_Y_START_POS,
                x=CAR_X_START_POS,
                locationType=LocationType.empty,
                facing=Facing.north,
                result="Home",
            ),
            facing_radian=math.pi / 2,
        )

        arena = [
            [
                Position(x=b, y=a, locationType=LocationType.empty)
                for b in range(GRID_COUNT)
            ]
            for a in range(GRID_COUNT)
        ]

        for obstacle in data:
            # print(obstacle)
            facing = None
            if obstacle["dir"] == "N":
                facing = Facing.north
            elif obstacle["dir"] == "S":
                facing = Facing.south
            elif obstacle["dir"] == "W":
                facing = Facing.west
            else:
                facing = Facing.east
            x = int(obstacle["x"])
            y = int(obstacle["y"])
            id = int(obstacle["id"])
            print(id)
            arena[y][x].locationType = LocationType.obstacle
            arena[y][x].facing = facing
            arena[y][x].id = id

        game = GameTask1(arena=arena, car=car)
        self.gametask1 = game
        # print(game)
        self.solve_game_task1()

    def solve_game_task1(self):
        if self.gametask1 is None:
            print("WTF MAN")
            return

        game_solver = GameSolverTask1(game=self.gametask1)
        game, distance_matrix, sale_path, mapping = game_solver.solve()
        print(game)
        print(distance_matrix)
        print(sale_path.movement_string)
        print(mapping)
        self.sale_path = sale_path

        try:
            # self.visualiser.display_game(game=game, distance_matrix=distance_matrix, sale_path=sale_path, mapping=mapping)
            pass
        except:
            pass
        self.task1_string_solution = sale_path.movement_string
        self.task1_index = 0
        self.update_obstaclescanning_reached_obstacle()

--------------------------------------------------------------------------------
File: ComputerServer/main.py
from PathFinding_task1.game_solver import GameSolverTask1
from ObjectTypes.object_types import * 
from PathFinding_task1.constants import * 
import math 
import json 

class AlgoMain:
    def __init__(self, obstacle_pos: str):
        self.gametask1 = None 
        self.sale_path = None 
        self.obstacle_pos = obstacle_pos

    def main(self):
        print(self.obstacle_pos)
        obstacle_positions = self.obstacle_pos.replace("'", '"')
        # obstacle_positions = self.obstacle_pos
        data = json.loads(obstacle_positions)
        positions = []
        car = Car(
            current_position=Position(
                y=CAR_Y_START_POS,
                x=CAR_X_START_POS,
                locationType=LocationType.empty,
                facing=Facing.north,
                result="Home",
            ),
            facing_radian=math.pi / 2,
        )

        arena = [
            [
                Position(x=b, y=a, locationType=LocationType.empty)
                for b in range(GRID_COUNT)
            ]
            for a in range(GRID_COUNT)
        ]

        for obstacle in data:
            # print(obstacle)
            facing = None
            if obstacle["dir"] == "N":
                facing = Facing.north
            elif obstacle["dir"] == "S":
                facing = Facing.south
            elif obstacle["dir"] == "W":
                facing = Facing.west
            else:
                facing = Facing.east
            x = int(obstacle["x"])
            y = int(obstacle["y"])
            id = int(obstacle["id"])
            print(id)
            arena[y][x].locationType = LocationType.obstacle
            arena[y][x].facing = facing
            arena[y][x].id = id

        game = GameTask1(arena=arena, car=car)
        self.gametask1 = game
        # print(game)
        self.solve_game_task1()
        commands = json_dump(self.sale_path.movement_string, indent=4)
        return commands

    def solve_game_task1(self):
        if self.gametask1 is None:
            print("WTF MAN")
            return

        game_solver = GameSolverTask1(game=self.gametask1)
        game, distance_matrix, sale_path, mapping = game_solver.solve()
        print(game)
        print(distance_matrix)
        print(sale_path.movement_string)
        print(mapping)
        self.sale_path = sale_path


if __name__ == "__main__":
    print("main")
    def convert_to_command(movement_seq, dest):
        command_dict = {
            "straight": "S",
            "right": "R",
            "left": "L",
            "forward": "F",
            "backward": "B",
            "reset": "G",
        }

        def calculate_degree(distance):
            radian = distance / CAR_TURNING_RADIUS
            degree = radian * (180 / math.pi)
            return degree

        command_list = [f"{MOVING_TAG}{dest}"]

        for move in movement_seq:

            position_update = {}
            position_update["car_position"] = {"x": move.end_position.x,
                                               "y": move.end_position.y,
                                               "dir": move.end_position.facing.value}
            if move.distance_cm == 0:
                continue

            if move.start_position.x == -1:
                command = "G"
            else:
                distance = move.distance_cm
                backwards = False
                if distance < 0:
                    backwards = True
                    distance = -distance

                direction = move.direction
                if direction == Direction.right:
                    degree = calculate_degree(distance)
                    formatted_degree = f"{int(degree):03d}"
                    command = "R" + formatted_degree
                elif direction == Direction.straight:
                    formatted_distance = f"{int(distance):03d}"
                    command = "S" + formatted_distance
                elif direction == Direction.left:
                    degree = calculate_degree(distance)
                    formatted_degree = f"{int(degree):03d}"
                    command = "L" + formatted_degree

                if backwards:
                    command = command[:1] + "B" + command[1:]
                else:
                    command = command[:1] + "F" + command[1:]
            position_update['command'] = command
            command_list.append(position_update)

        command_list.append("--scan image--")

        
        return command_list
    
    movement_seq = [
                    Movement(distance_cm=20.0, turning_radian=2.3, direction=Direction.right, 
                             start_position=Position(x=15, y=20, locationType=LocationType.landing), end_position=Position(x=15, y=20, locationType=LocationType.landing))
                            ,
                    Movement(distance_cm=20.0, turning_radian=2.3, direction=Direction.right, 
                             start_position=Position(x=15, y=20, locationType=LocationType.landing), end_position=Position(x=15, y=20, locationType=LocationType.landing))
                    ]
    movement_string = [] 
    movement_string += convert_to_command(movement_seq, 1)
    movement_string += convert_to_command(movement_seq, 2)
    json_dump = json.dumps(movement_string, indent=4)
    print(json_dump)
--------------------------------------------------------------------------------
File: PathFinding_task2/visualiser.py
import pygame
import math
from typing import List
import random
import numpy as np
from datetime import datetime, timedelta
import time

from ObjectTypes.object_types import (
    GameTask1,
    Position,
    LocationType,
    Facing,
    MinimumPath,
    Direction,
    Movement,
    TravelledSalesman,
)
from PathFinding_task1.constants import (
    WHITE,
    SCALE_FACTOR,
    START_BOX_SIZE,
    YELLOW,
    BLACK,
    GRID_COUNT,
    GRID_SIZE,
    RED,
    GREEN,
    BLUE1,
    CAR_SPEED,
    TURNING_RADIAN_INCREMENT,
    CAR_TURNING_RADIUS,
    RENDER_SPEED,
)

pygame.init()


class Visualiser:

    def __init__(self, width: int = 200, height: int = 400) -> None:
        self.width = width
        self.height = height
        self.display = pygame.display.set_mode(
            (self.width * SCALE_FACTOR, self.height * SCALE_FACTOR)
        )
        pygame.display.set_caption("Path Finding")
        self.car_image = pygame.image.load("car.png").convert_alpha()
        self.car_image = pygame.transform.scale(
            self.car_image, (15 * SCALE_FACTOR, 25 * SCALE_FACTOR)
        )
        self.colors = [self._random_color() for _ in range(10000)]
        self.font = pygame.font.Font(None, 4 * SCALE_FACTOR)

    def _random_color(self):
        return (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))

    def _display_vector(self, start_vector: Position, end_vector: Position, color):
        pygame.draw.line(
            self.display,
            color,
            (
                start_vector.x * SCALE_FACTOR,
                (self.width - start_vector.y) * SCALE_FACTOR,
            ),
            (end_vector.x * SCALE_FACTOR, (self.height - end_vector.y) * SCALE_FACTOR),
            width=3,
        )

    def _display_turn(self, movement: Movement, color):

        if movement.circle_center is None:
            return

        circle_center_to_start = [
            movement.start_position.x - movement.circle_center.x,
            movement.start_position.y - movement.circle_center.y,
        ]
        circle_center_to_end = [
            movement.end_position.x - movement.circle_center.x,
            movement.end_position.y - movement.circle_center.y,
        ]
        start_rad = np.arctan2(circle_center_to_start[1], circle_center_to_start[0]) % (
            2 * np.pi
        )
        end_rad = np.arctan2(circle_center_to_end[1], circle_center_to_end[0]) % (
            2 * np.pi
        )

        if (movement.direction == Direction.left and movement.distance_cm > 0) or (
            movement.direction == Direction.right and movement.distance_cm < 0
        ):
            rad_1 = start_rad
            rad_2 = end_rad
        else:
            rad_1 = end_rad
            rad_2 = start_rad

        pygame.draw.arc(
            self.display,
            color,
            pygame.Rect(
                (
                    movement.circle_center.x * SCALE_FACTOR
                    - CAR_TURNING_RADIUS * SCALE_FACTOR,
                    (self.height - movement.circle_center.y) * SCALE_FACTOR
                    - CAR_TURNING_RADIUS * SCALE_FACTOR,
                ),
                (
                    CAR_TURNING_RADIUS * SCALE_FACTOR * 2,
                    CAR_TURNING_RADIUS * SCALE_FACTOR * 2,
                ),
            ),
            rad_1,
            rad_2,
            CAR_TURNING_RADIUS * SCALE_FACTOR,
        )

    def _determine_car_position(
        self, sale_path: TravelledSalesman, distance_covered: float
    ):

        index = 0
        working_distance_covered = distance_covered
        while working_distance_covered > 0 and index < len(sale_path.movement_path):
            working_distance_covered -= abs(sale_path.movement_path[index].distance_cm)
            index += 1

        if index == len(sale_path.movement_path) and working_distance_covered > 0:
            self.running = False
        current_movement = sale_path.movement_path[index - 1]
        # self._move_car(movement=current_movement)
        # print(f"Car is currently travelling {current_movement.direction}")

    def display_game_frame(
        self,
        distance_matrix: List[List[MinimumPath]],
        sale_path: TravelledSalesman,
    ):
        self.display.fill(WHITE)

        distance_covered = self.clock * CAR_SPEED
        self._determine_car_position(
            sale_path=sale_path, distance_covered=distance_covered
        )

        # print(time_since.seconds)
        ## Drawing Start Box
        pygame.draw.rect(
            self.display,
            YELLOW,
            pygame.Rect(
                0,
                (self.height - START_BOX_SIZE) * SCALE_FACTOR,
                START_BOX_SIZE * SCALE_FACTOR,
                START_BOX_SIZE * SCALE_FACTOR,
            ),
        )

        ## Drawing grid
        for i in range(GRID_COUNT):
            pygame.draw.line(
                self.display,
                BLACK,
                (0, i * GRID_SIZE * SCALE_FACTOR),
                (self.width * SCALE_FACTOR, i * GRID_SIZE * SCALE_FACTOR),
            )
            pygame.draw.line(
                self.display,
                BLACK,
                (i * GRID_SIZE * SCALE_FACTOR, 0),
                (i * GRID_SIZE * SCALE_FACTOR, self.height * SCALE_FACTOR),
            )

        seq_str = "5"
        for src_index in range(len(sale_path.obstacle_seq)):
            dest_index = (src_index + 1) % len(sale_path.obstacle_seq)
            y = sale_path.obstacle_seq[src_index]
            x = sale_path.obstacle_seq[dest_index]

            seq_str += f" -> {x}"
            if y == x:
                continue
            color = self.colors[y * GRID_COUNT + x]
            for path in distance_matrix[y][x].movements_to_take:
                start_pos = path.start_position
                end_pos = path.end_position
                movement_direction = path.direction

                if path.direction == Direction.straight:
                    self._display_vector(
                        start_vector=start_pos, end_vector=end_pos, color=color
                    )
                else:
                    self._display_turn(movement=path, color=color)
        for row in self.game.arena:
            for col in row:

                if col.locationType == LocationType.landing_padding:
                    # pygame.draw.rect(
                    #     self.display,
                    #     RED,
                    #     pygame.Rect(
                    #         (col.x * GRID_SIZE) * SCALE_FACTOR,
                    #         (self.height - (col.y + 1) * GRID_SIZE) * SCALE_FACTOR,
                    #         GRID_SIZE * SCALE_FACTOR,
                    #         GRID_SIZE * SCALE_FACTOR,
                    #     ),
                    # )
                    pass
                elif col.locationType == LocationType.obstacle:
                    pygame.draw.rect(
                        self.display,
                        BLUE1,
                        pygame.Rect(
                            (col.x * GRID_SIZE) * SCALE_FACTOR,
                            (self.height - (col.y + 1) * GRID_SIZE) * SCALE_FACTOR,
                            (GRID_SIZE) * SCALE_FACTOR,
                            (GRID_SIZE) * SCALE_FACTOR,
                        ),
                    )
                    if col.facing == Facing.east:
                        pygame.draw.rect(
                            self.display,
                            YELLOW,
                            pygame.Rect(
                                (col.x * GRID_SIZE + GRID_SIZE - 3) * SCALE_FACTOR,
                                (self.height - (col.y + 1) * GRID_SIZE) * SCALE_FACTOR,
                                (3) * SCALE_FACTOR,
                                (GRID_SIZE) * SCALE_FACTOR,
                            ),
                        )
                    elif col.facing == Facing.north:
                        pygame.draw.rect(
                            self.display,
                            YELLOW,
                            pygame.Rect(
                                (col.x * GRID_SIZE) * SCALE_FACTOR,
                                (self.height - (col.y + 1) * GRID_SIZE) * SCALE_FACTOR,
                                (GRID_SIZE) * SCALE_FACTOR,
                                (3) * SCALE_FACTOR,
                            ),
                        )
                    elif col.facing == Facing.west:
                        pygame.draw.rect(
                            self.display,
                            YELLOW,
                            pygame.Rect(
                                (col.x * GRID_SIZE) * SCALE_FACTOR,
                                (self.height - (col.y + 1) * GRID_SIZE) * SCALE_FACTOR,
                                (3) * SCALE_FACTOR,
                                (GRID_SIZE) * SCALE_FACTOR,
                            ),
                        )
                    elif col.facing == Facing.south:
                        pygame.draw.rect(
                            self.display,
                            YELLOW,
                            pygame.Rect(
                                (col.x * GRID_SIZE) * SCALE_FACTOR,
                                (self.height - (col.y + 1) * GRID_SIZE + GRID_SIZE - 3)
                                * SCALE_FACTOR,
                                (GRID_SIZE) * SCALE_FACTOR,
                                (3) * SCALE_FACTOR,
                            ),
                        )

                elif col.locationType == LocationType.landing:
                    color = GREEN
                    pygame.draw.rect(
                        self.display,
                        color,
                        pygame.Rect(
                            (col.x * GRID_SIZE) * SCALE_FACTOR,
                            (self.height - (col.y + 1) * GRID_SIZE) * SCALE_FACTOR,
                            GRID_SIZE * SCALE_FACTOR,
                            GRID_SIZE * SCALE_FACTOR,
                        ),
                    )
                    text_surface = self.font.render(str(col.result), True, (0, 0, 0))
                    text_rect = text_surface.get_rect()
                    text_rect.center = (
                        (col.x * GRID_SIZE + GRID_SIZE / 2) * SCALE_FACTOR,
                        (self.height - (col.y + 1) * GRID_SIZE + GRID_SIZE / 2)
                        * SCALE_FACTOR,
                    )
                    self.display.blit(text_surface, text_rect)

        rotated_image = pygame.transform.rotate(
            self.car_image, math.degrees(self.game.car.facing_radian - math.pi / 2)
        )
        # print(
        #     f"Car x: {self.game.car.current_position.x} Car y: {self.game.car.current_position.y}"
        # )
        rotated_rect = rotated_image.get_rect(
            center=(
                self.game.car.current_position.x * SCALE_FACTOR,
                (self.height - self.game.car.current_position.y) * SCALE_FACTOR,
            )
        )
        self.display.blit(rotated_image, rotated_rect.topleft)

        text_surface = self.font.render(str(seq_str), True, (0, 0, 0))
        text_rect = text_surface.get_rect()
        text_rect.center = (100, 20)
        self.display.blit(text_surface, text_rect)

        pygame.display.update()  # Update the display after drawing
        self._increment_clock()

    def _increment_clock(self):
        time.sleep(RENDER_SPEED)
        self.clock += 1

    def _print_movement(self, movement: Movement):
        gear = "forward"
        if movement.distance_cm < 0:
            gear = "backward"
        print(f"Car moving {gear}, turning: {movement.direction.name} for distance: {movement.distance_cm} cm\tTurn by {movement.turning_radian}")

    def _move_car(self, movement: Movement):
        x = self.game.car.current_position.x
        y = self.game.car.current_position.y
        current_facing = self.game.car.facing_radian

        # self._print_movement(movement=movement)
        try:
            if movement.direction == Direction.straight and movement.distance_cm > 0:
                new_facing = self.game.car.facing_radian
                delta_x = np.cos(new_facing) * CAR_SPEED
                delta_y = np.sin(new_facing) * CAR_SPEED
                new_x = x + delta_x
                new_y = y + delta_y
            elif movement.direction == Direction.straight and movement.distance_cm < 0:
                new_facing = self.game.car.facing_radian
                delta_x = np.cos(new_facing) * CAR_SPEED
                delta_y = np.sin(new_facing) * CAR_SPEED
                new_x = x - delta_x
                new_y = y - delta_y
            elif movement.direction == Direction.left and movement.distance_cm > 0:
                new_facing = (current_facing + TURNING_RADIAN_INCREMENT) % (math.pi * 2)
                center_x = x - CAR_TURNING_RADIUS * np.sin(current_facing)
                center_y = y + CAR_TURNING_RADIUS * np.cos(current_facing)
                new_x = center_x + CAR_TURNING_RADIUS * np.sin(
                    current_facing + TURNING_RADIAN_INCREMENT
                )
                new_y = center_y - CAR_TURNING_RADIUS * np.cos(
                    current_facing + TURNING_RADIAN_INCREMENT
                )

            elif movement.direction == Direction.left and movement.distance_cm < 0:
                new_facing = (current_facing - TURNING_RADIAN_INCREMENT) % (math.pi * 2)
                center_x = x + CAR_TURNING_RADIUS * np.sin(current_facing)
                center_y = y - CAR_TURNING_RADIUS * np.cos(current_facing)
                new_x = center_x - CAR_TURNING_RADIUS * np.sin(
                    current_facing + TURNING_RADIAN_INCREMENT
                )
                new_y = center_y + CAR_TURNING_RADIUS * np.cos(
                    current_facing + TURNING_RADIAN_INCREMENT
                )

            elif movement.direction == Direction.right and movement.distance_cm > 0:
                new_facing = (current_facing - TURNING_RADIAN_INCREMENT) % (math.pi * 2)
                center_x = x + CAR_TURNING_RADIUS * np.sin(current_facing)
                center_y = y - CAR_TURNING_RADIUS * np.cos(current_facing)
                new_x = center_x - CAR_TURNING_RADIUS * np.sin(
                    current_facing - TURNING_RADIAN_INCREMENT
                )
                new_y = center_y + CAR_TURNING_RADIUS * np.cos(
                    current_facing - TURNING_RADIAN_INCREMENT
                )

            elif movement.direction == Direction.right and movement.distance_cm < 0:
                new_facing = (current_facing + TURNING_RADIAN_INCREMENT) % (math.pi * 2)
                center_x = x - CAR_TURNING_RADIUS * np.sin(current_facing)
                center_y = y + CAR_TURNING_RADIUS * np.cos(current_facing)
                new_x = center_x + CAR_TURNING_RADIUS * np.sin(
                    current_facing - TURNING_RADIAN_INCREMENT
                )
                new_y = center_y - CAR_TURNING_RADIUS * np.cos(
                    current_facing - TURNING_RADIAN_INCREMENT
                )

            self.game.car.current_position.x = new_x
            self.game.car.current_position.y = new_y
            self.game.car.facing_radian = new_facing
        except Exception as e:
            print(movement)

    def _print_movement_path(self, sale_path: TravelledSalesman):
        for move in sale_path.movement_path:
            print(f"Move {move.direction} in {move.distance_cm}cm")

    def display_game(
        self,
        game: GameTask1,
        distance_matrix: List[List[MinimumPath]],
        sale_path: TravelledSalesman,
    ):
        self.running = True
        self.clock = 0
        self.game = game
        print("Starting pygame display")
        # self._print_movement_path(sale_path=sale_path)
        while self.running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False

            self.display_game_frame(
                distance_matrix=distance_matrix, sale_path=sale_path
            )

        pygame.quit()


# if __name__ == "__main__":
#     visualizer = Visualiser()
#     running = True
#     while running:
#         for event in pygame.event.get():
#             if event.type == pygame.QUIT:
#                 running = False

#         visualizer.display_game()

#     pygame.quit()

--------------------------------------------------------------------------------
File: PathFinding_task2/constants.py
from ObjectTypes.object_types import Direction

WHITE = (255, 255, 255)
RED = (252, 203, 199)
BLUE1 = (0, 0, 255)
BLUE2 = (0, 100, 255)
BLACK = (0, 0, 0)
YELLOW = (255, 255, 0)
DARK_RED = (139, 0, 0)
LIGHT_RED = (255, 102, 102)
DARK_BLUE = (0, 0, 139)
LIGHT_BLUE = (173, 216, 230)
DARK_GRAY = (169, 169, 169)
LIGHT_GRAY = (211, 211, 211)
GREEN = (217, 255, 230)
DARK_GREEN = (0, 100, 0)
ORANGE = (255, 165, 0)
PURPLE = (128, 0, 128)
PINK = (255, 192, 203)
CYAN = (0, 255, 255)
MAGENTA = (255, 0, 255)

SCALE_FACTOR = 4
START_BOX_SIZE = 30
GRID_COUNT = 20
CAR_X_START_POS = 5
CAR_Y_START_POS = 5
OBSTACLE_COUNT = 5
ARENA_SIZE = 200
REVERSE_STRAIGHT_DISTANCE = 20
CAR_SPEED = 1
CAR_TURNING_RADIUS = 31
RENDER_SPEED = 0.01
TURNING_RADIAN_INCREMENT = CAR_SPEED / CAR_TURNING_RADIUS
GRID_SIZE = ARENA_SIZE // GRID_COUNT
LOWER_GRID_BOUND = 5
HIGHER_GRID_BOUND = 195
CAR_BACK_TO_CENTER = 8

SAFETY_DISTANCE_EDGE = 5
SAFETY_DISTANCE_OBSTACLE = 10
SAFETY_DISTANCE_TURNING_OBSTACLE = 38
SAFETY_DISTANCE_TURNING_EDGE = 35
LANDING_DISTANCE = 4
ANGLE_SUPPLEMENT = 0.2

RCHED_LOC_TAG = "RECHED_LOC_TAG:"
TASK2_DISTANCE_NEXT_TO_OBSTACLE_1 = 25
TASK2_CAR_START_X = 100
TASK2_CAR_START_Y = 25
TASK2_CAR_ASS_OUTOFPARKING = 20
# TASK2_BUFFER_OBSTACLE2 = 15
LEGAL_MOVES = [
    [Direction.left, Direction.straight, Direction.left],  # Done
    [Direction.left, Direction.straight, Direction.right],  # Done
    [Direction.left, Direction.right, Direction.left],
    [Direction.right, Direction.straight, Direction.left],  # Done
    [Direction.right, Direction.straight, Direction.right],  # Done
    [Direction.right, Direction.left, Direction.right],
]

--------------------------------------------------------------------------------
File: PathFinding_task2/Task2_Pathfinding_Manager.py
from ObjectTypes.object_types import *
from PathFinding_task2.constants import *
from PathFinding_task2.game_solver import GameSolverTask2
from ComputerServer.data_manager import DataManager
import numpy as np


def point_to_segment_distance(px, py, x1, y1, x2, y2):
    # Convert points to numpy arrays for easier calculations
    P = np.array([px, py])
    A = np.array([x1, y1])
    B = np.array([x2, y2])

    # Vector AB
    AB = B - A
    # Vector AP
    AP = P - A
    # Vector BP
    BP = P - B

    # Calculate the squared length of AB
    AB_squared = np.dot(AB, AB)

    if AB_squared == 0:  # A and B are the same point
        return np.linalg.norm(AP)  # Distance from P to A (or 😎

    # Project point P onto the line defined by A and B
    t = np.dot(AP, AB) / AB_squared

    if t < 0:  # P projects out the line segment, nearest to A
        nearest_point = A
    elif t > 1:  # P projects out the line segment, nearest to B
        nearest_point = B
    else:  # P projects onto the line segment
        nearest_point = A + t * AB

    # Calculate the distance from P to the nearest point
    distance = np.linalg.norm(P - nearest_point)
    return distance

class Pathfinding_Task2_Manager:
    def __init__(self):
        self.data_manager = None
        self.game_solver = GameSolverTask2()
        self.parking_to_obstacle1_updated = False
        self.next_to_obstacle1_to_south_of_obstacle1_updated = False
        self.car_position = Position(x=TASK2_CAR_START_X,y=TASK2_CAR_START_Y,locationType=LocationType.empty)
        pass

    def set_data_manager(self, data_manager: DataManager):
        self.data_manager = data_manager

    def run(self):
        while True:
            self.update_path()

    def update_path(self):
        if self.data_manager is None:
            print("No data manager in Path Finding")
            return

        if self.data_manager.task2progress == Task2Progress.car_initial_parked and not self.parking_to_obstacle1_updated:
            if self.data_manager.obstacle1_distance_from_parking is None:
                print("Need distance to obstacle 1 first")
                return
            if self.data_manager.obstacle1_arrow == ArrowDirection.none:
                print("Need the direction of obstacle 1 first")
                return
            self.game_solver.obstacle.append(Position(x=TASK2_CAR_START_X, y=TASK2_CAR_START_Y + self.data_manager.obstacle1_distance_from_parking, locationType = LocationType.obstacle))
            if self.data_manager.obstacle1_arrow == ArrowDirection.left:
                pos = Position(x=TASK2_CAR_START_X - TASK2_DISTANCE_NEXT_TO_OBSTACLE_1, y = TASK2_CAR_START_Y + self.data_manager.obstacle1_distance_from_parking + GRID_SIZE // 2 + TASK2_CAR_ASS_OUTOFPARKING + 5, locationType = LocationType.landing)
                move_index = 1
            else:
                pos = Position(x=TASK2_CAR_START_X + TASK2_DISTANCE_NEXT_TO_OBSTACLE_1, y = TASK2_CAR_START_Y + self.data_manager.obstacle1_distance_from_parking + GRID_SIZE // 2 + TASK2_CAR_ASS_OUTOFPARKING + 5, locationType = LocationType.landing)
                move_index = 3

            self.data_manager.add_task2_move(f"SF0{TASK2_CAR_ASS_OUTOFPARKING}")

            self.car_position.y += 20

            total_distance, path = self.game_solver.solve_move_safe_path(move_index, src=self.car_position, dest=pos)
            string_path = self.game_solver.convert_to_command(path)
            for item in string_path:
                self.data_manager.add_task2_move(item)

            self.data_manager.add_task2_move(f"{RCHED_LOC_TAG}{Task2Progress.next_to_obstacle_1.value}")
            self.parking_to_obstacle1_updated = True
            self.car_position = pos

        elif self.data_manager.task2progress == Task2Progress.next_to_obstacle_1 and not self.next_to_obstacle1_to_south_of_obstacle1_updated:
            if self.data_manager.obstacle2_distance_from_obstacle1 is None:
                print("Need to update distance from obstacle1 to obstacle2")
                return
            if self.data_manager.obstacle2_width is None:
                print("Need to update width of obstacle2")
                return
            if self.data_manager.obstacle2_arrow == ArrowDirection.none:
                print("Need to update direction of arrow 2")
                return

            y = self.car_position.y + self.data_manager.obstacle2_distance_from_obstacle1 + 25
            x_left_obstacle2 = TASK2_CAR_START_X - self.data_manager.obstacle2_width // 2 - CAR_TURNING_RADIUS
            x_right_obstacle2 = TASK2_CAR_START_X + self.data_manager.obstacle2_width // 2 + CAR_TURNING_RADIUS

            landing_left_obstacle2 = Position(y=y ,x=x_left_obstacle2,locationType=LocationType.landing)
            landing_right_obstacle2 = Position(y=y ,x=x_right_obstacle2,locationType=LocationType.landing)
            dest = None
            move_index = None
            if self.data_manager.obstacle2_arrow == ArrowDirection.left:
                dest = landing_left_obstacle2
            elif self.data_manager.obstacle2_arrow == ArrowDirection.right:
                dest = landing_right_obstacle2

            if self.data_manager.obstacle1_arrow == ArrowDirection.left:
                if self.data_manager.obstacle2_arrow == ArrowDirection.left:
                    move_index = 1
                elif self.data_manager.obstacle2_arrow == ArrowDirection.right:
                    move_index = 3
            elif self.data_manager.obstacle1_arrow == ArrowDirection.right:
                if self.data_manager.obstacle2_arrow == ArrowDirection.right:
                    move_index = 3
                elif self.data_manager.obstacle2_arrow == ArrowDirection.left:
                    move_index = 1

            if move_index is None or dest is None:
                print("Move index or Destination is none")
                return
            total_distance, path = self.game_solver.solve_move_safe_path(move_index, src=self.car_position, dest=dest)
            string_path = self.game_solver.convert_to_command(path)
            print(f"{string_path=}")
            for item in string_path:
                self.data_manager.add_task2_move(item)

            self.car_position = dest

            if self.data_manager.obstacle2_arrow == ArrowDirection.left:
                move_index = 4
                landing_right_obstacle2.facing = Facing.south
                total_distance, path = self.game_solver.solve_move_safe_path(move_index, src=self.car_position, dest=landing_right_obstacle2)
                self.car_position = landing_right_obstacle2
            elif self.data_manager.obstacle2_arrow == ArrowDirection.right:
                move_index = 0
                landing_left_obstacle2.facing = Facing.south
                total_distance, path = self.game_solver.solve_move_safe_path(move_index, src=self.car_position, dest=landing_left_obstacle2)
                self.car_position = landing_left_obstacle2

            string_path_1 = self.game_solver.convert_to_command(path)

            for item in string_path_1:
                self.data_manager.add_task2_move(item)

            distance = point_to_segment_distance(px=CAR_X_START_POS,
                                                 py=TASK2_CAR_START_Y + self.data_manager.obstacle1_distance_from_parking + 5,
                                                 x1=self.car_position.x, y1=self.car_position.y, x2=CAR_X_START_POS,
                                                 y2=CAR_Y_START_POS + 15)

            distance_left_obs = point_to_segment_distance(px=CAR_X_START_POS - 30,
                                                 py=TASK2_CAR_START_Y,
                                                 x1=self.car_position.x, y1=self.car_position.y, x2=CAR_X_START_POS,
                                                 y2=CAR_Y_START_POS + 15)

            distance_right_obs = point_to_segment_distance(px=CAR_X_START_POS + 30,
                                                          py=TASK2_CAR_START_Y,
                                                          x1=self.car_position.x, y1=self.car_position.y,
                                                          x2=CAR_X_START_POS,
                                                          y2=CAR_Y_START_POS + 15)
            added_distance = 30
            print(distance)
            # TODO: HERE
            execute = True
            # execute = False
            if execute and (distance < 15 or distance_right_obs < 10 or distance_left_obs < 10):
                location_next_to_obstacle1 = None
                added_distance = 10
                if self.data_manager.obstacle2_arrow == ArrowDirection.left:
                    location_next_to_obstacle1 = Position(x=TASK2_CAR_START_X + TASK2_DISTANCE_NEXT_TO_OBSTACLE_1, y=TASK2_CAR_START_Y + self.data_manager.obstacle1_distance_from_parking + 25, locationType=LocationType.landing, facing=Facing.south)
                    move_index = 3
                elif self.data_manager.obstacle2_arrow == ArrowDirection.right:
                    location_next_to_obstacle1 = Position(x=TASK2_CAR_START_X - TASK2_DISTANCE_NEXT_TO_OBSTACLE_1, y=TASK2_CAR_START_Y + self.data_manager.obstacle1_distance_from_parking + 25, locationType=LocationType.landing, facing=Facing.south)
                    move_index = 1
                if location_next_to_obstacle1 is None:
                    print("No landing next to obstacle 1")
                    return

                total_distance, path = self.game_solver.solve_move_safe_path(move_index, src=self.car_position,
                                                                             dest=location_next_to_obstacle1)
                self.car_position = location_next_to_obstacle1
                string_path = self.game_solver.convert_to_command(path)
                for item in string_path:
                    self.data_manager.add_task2_move(item)
                self.data_manager.add_task2_move(f"{RCHED_LOC_TAG}{Task2Progress.next_to_obstacle_1_on_return.value}")
            final_position = Position(x=TASK2_CAR_START_X, y=TASK2_CAR_START_Y + added_distance, locationType=LocationType.landing, facing=Facing.south)
            total_distance, path = self.game_solver.solve_move_safe_path(move_index, src=self.car_position,
                                                                         dest=final_position)
            self.car_position = final_position
            string_path = self.game_solver.convert_to_command(path)
            for index, item in enumerate(string_path):
                if index == len(string_path) - 1:
                    break
                self.data_manager.add_task2_move(item)
                self.data_manager.add_task2_move(f"{RCHED_LOC_TAG}{Task2Progress.parking_car.value}")

            self.next_to_obstacle1_to_south_of_obstacle1_updated = True

--------------------------------------------------------------------------------
File: PathFinding_task2/game_solver.py
from ObjectTypes.object_types import (
    GameTask1,
    Position,
    LocationType,
    Facing,
    Direction,
    MinimumPath,
    Movement,
    TravelledSalesman,
)
from PathFinding_task2.constants import *
import math
from typing import List
import numpy as np


class GameSolverTask2:

    def __init__(self) -> None:
        self.obstacle = []
        pass

    def _vector_properties(self, vector):
        length = np.linalg.norm(vector)
        angle_rad = np.arctan2(vector[1], vector[0]) % (2 * np.pi)
        return length, angle_rad

    def _angle_between_vectors(self, v1, v2):
        v1 = np.array(v1)
        v2 = np.array(v2)

        if v1.shape[0] != 2 or v2.shape[0] != 2:
            raise ValueError("The function currently supports only 2D vectors.")

        dot_product = np.dot(v1, v2)

        mag_v1 = np.linalg.norm(v1)
        mag_v2 = np.linalg.norm(v2)

        cos_theta = dot_product / (mag_v1 * mag_v2)

        cos_theta = np.clip(cos_theta, -1.0, 1.0)

        angle_rad = np.arccos(cos_theta)

        cross_product_z = v1[0] * v2[1] - v1[1] * v2[0]

        if cross_product_z < 0:
            angle_rad = 2 * np.pi - angle_rad

        return angle_rad

    def _compute_arc_length(self, angle_rad):
        arc_length = CAR_TURNING_RADIUS * angle_rad
        return abs(arc_length)

    def _compute_arccos(self, value):
        value = np.clip(value, -1.0, 1.0)
        return np.arccos(value)

    def _rotate_vector(self, vector, radians):
        rotation_matrix = np.array(
            [[np.cos(radians), -np.sin(radians)], [np.sin(radians), np.cos(radians)]]
        )
        v_rotated = np.dot(rotation_matrix, vector)

        return v_rotated

    def _normalize_vector(self, vector):
        try:
            return vector / np.linalg.norm(vector)
        except Exception as e:
            print(e)
            raise e

    def solve_move_safe_path(
        self, move_index: int, src: Position, dest: Position
    ):
        moves_to_make = []
        move = LEGAL_MOVES[move_index]
        total_distance = math.inf
        if move_index < 6:
            dest_circle_x, dest_circle_y = self._get_circle_position(
                position=dest, move=move[2]
            )
            src_circle_x, src_circle_y = self._get_circle_position(
                position=src, move=move[0]
            )

        elif move_index == 6 or move_index == 7:
            dest_circle_x, dest_circle_y = self._get_circle_position(
                position=dest, move=move[1]
            )
            src_circle_x, src_circle_y = self._get_circle_position(
                position=src, move=move[0]
            )
            distance = math.sqrt(
                (dest_circle_x - src_circle_x) ** 2
                + (dest_circle_y - src_circle_y) ** 2
            )
            if distance > CAR_TURNING_RADIUS * 2:
                return total_distance, moves_to_make
            else:
                if move_index == 6:  # [Direction.right, Direction.left],
                    v1 = np.array(
                        [dest_circle_x - src_circle_x, dest_circle_y - src_circle_y]
                    )

                    c1_normal_vector = self._normalize_vector(vector=v1)

                    c1_tangent_point = (
                        np.array([src_circle_x, src_circle_y])
                        + CAR_TURNING_RADIUS * c1_normal_vector
                    )
                    c2_tangent_point = (
                        np.array([dest_circle_x, dest_circle_y])
                        - CAR_TURNING_RADIUS * c1_normal_vector
                    )

                    c1_to_src_vector = np.array(
                        [src.x - src_circle_x, src.y - src_circle_y]
                    )
                    angle_c1 = self._angle_between_vectors(
                        c1_normal_vector, c1_to_src_vector
                    )

                    c2_to_dest_vector = np.array(
                        [dest.x - dest_circle_x, dest.y - dest_circle_y]
                    )
                    angle_c2 = self._angle_between_vectors(
                        c1_normal_vector * -1, c2_to_dest_vector
                    )

                    total_distance = self._compute_arc_length(
                        angle_rad=angle_c1
                    ) + self._compute_arc_length(angle_rad=angle_c2)

                    right_turn_1 = Movement(
                        distance_cm=self._compute_arc_length(angle_rad=angle_c1),
                        turning_radian=angle_c1,
                        direction=Direction.right,
                        start_position=src,
                        end_position=Position(
                            x=c1_tangent_point[0],
                            y=c1_tangent_point[1],
                            locationType=LocationType.empty,
                        ),
                        circle_center=Position(
                            x=src_circle_x,
                            y=src_circle_y,
                            locationType=LocationType.empty,
                        ),
                    )
                    moves_to_make.append(right_turn_1)

                    left_turn_1 = Movement(
                        distance_cm=self._compute_arc_length(angle_rad=angle_c2),
                        turning_radian=angle_c1,
                        direction=Direction.left,
                        start_position=Position(
                            x=c1_tangent_point[0],
                            y=c1_tangent_point[1],
                            locationType=LocationType.empty,
                        ),
                        end_position=dest,
                        circle_center=Position(
                            x=src_circle_x,
                            y=src_circle_y,
                            locationType=LocationType.empty,
                        ),
                    )
                    moves_to_make.append(left_turn_1)
                elif move_index == 7:  # [Direction.left, Direction.right],
                    v1 = np.array(
                        [dest_circle_x - src_circle_x, dest_circle_y - src_circle_y]
                    )

                    c1_normal_vector = self._normalize_vector(vector=v1)

                    c1_tangent_point = (
                        np.array([src_circle_x, src_circle_y])
                        + CAR_TURNING_RADIUS * c1_normal_vector
                    )
                    c2_tangent_point = (
                        np.array([dest_circle_x, dest_circle_y])
                        - CAR_TURNING_RADIUS * c1_normal_vector
                    )

                    c1_to_src_vector = np.array(
                        [src.x - src_circle_x, src.y - src_circle_y]
                    )
                    angle_c1 = self._angle_between_vectors(
                        c1_to_src_vector, c1_normal_vector
                    )

                    c2_to_dest_vector = np.array(
                        [dest.x - dest_circle_x, dest.y - dest_circle_y]
                    )
                    angle_c2 = self._angle_between_vectors(
                        c2_to_dest_vector, c1_normal_vector * -1
                    )

                    total_distance = self._compute_arc_length(
                        angle_rad=angle_c1
                    ) + self._compute_arc_length(angle_rad=angle_c2)

                    left_turn_1 = Movement(
                        distance_cm=self._compute_arc_length(angle_rad=angle_c1),
                        turning_radian=angle_c1,
                        direction=Direction.left,
                        start_position=src,
                        end_position=Position(
                            x=c1_tangent_point[0],
                            y=c1_tangent_point[1],
                            locationType=LocationType.empty,
                        ),
                        circle_center=Position(
                            x=src_circle_x,
                            y=src_circle_y,
                            locationType=LocationType.empty,
                        ),
                    )
                    moves_to_make.append(left_turn_1)

                    right_turn_1 = Movement(
                        distance_cm=self._compute_arc_length(angle_rad=angle_c2),
                        turning_radian=angle_c1,
                        direction=Direction.right,
                        start_position=Position(
                            x=c1_tangent_point[0],
                            y=c1_tangent_point[1],
                            locationType=LocationType.empty,
                        ),
                        end_position=dest,
                        circle_center=Position(
                            x=src_circle_x,
                            y=src_circle_y,
                            locationType=LocationType.empty,
                        ),
                    )
                    moves_to_make.append(right_turn_1)
        elif move_index == 8 or move_index == 9:
            dest_circle_x, dest_circle_y = self._get_circle_position(
                position=dest, move=move[0]
            )
            src_circle_x, src_circle_y = self._get_circle_position(
                position=src, move=move[0]
            )
            distance = math.sqrt(
                (dest_circle_x - src_circle_x) ** 2
                + (dest_circle_y - src_circle_y) ** 2
            )
            if distance > 0:
                return total_distance, moves_to_make
            else:
                if move_index == 8:  # [Direction.right],
                    src_vector = np.array([src.x - src_circle_x, src.y - src_circle_y])
                    dest_vector = np.array(
                        [dest.x - dest_circle_x, dest.y - dest_circle_y]
                    )
                    angle = self._angle_between_vectors(dest_vector, src_vector)

                    right_turn = Movement(
                        distance_cm=self._compute_arc_length(angle_rad=angle),
                        turning_radian=angle,
                        direction=Direction.right,
                        start_position=src,
                        end_position=dest,
                        circle_center=Position(
                            x=src_circle_x,
                            y=src_circle_y,
                            locationType=LocationType.empty,
                        ),
                    )

                    moves_to_make.append(right_turn)
                elif move_index == 9:  # [Direction.left],
                    src_vector = np.array([src.x - src_circle_x, src.y - src_circle_y])
                    dest_vector = np.array(
                        [dest.x - dest_circle_x, dest.y - dest_circle_y]
                    )
                    angle = self._angle_between_vectors(src_vector, dest_vector)

                    left_turn = Movement(
                        distance_cm=self._compute_arc_length(angle_rad=angle),
                        turning_radian=angle,
                        direction=Direction.left,
                        start_position=src,
                        end_position=dest,
                        circle_center=Position(
                            x=src_circle_x,
                            y=src_circle_y,
                            locationType=LocationType.empty,
                        ),
                    )

                    moves_to_make.append(left_turn)

        distance = math.sqrt(
            (dest_circle_x - src_circle_x) ** 2 + (dest_circle_y - src_circle_y) ** 2
        )
        if move_index == 0:  # [Direction.left, Direction.straight, Direction.left],
            v1 = np.array([dest_circle_x - src_circle_x, dest_circle_y - src_circle_y])
            v1_normal = np.array([v1[1], -v1[0]])

            v1_normal = self._normalize_vector(v1_normal)

            c1_tangent_point = (
                np.array([src_circle_x, src_circle_y]) + CAR_TURNING_RADIUS * v1_normal
            )
            c2_tangent_point = c1_tangent_point + v1
            straighline_distance, straight_line_angle_of_travel = (
                self._vector_properties(v1)
            )

            c1_to_src_vector = np.array([src.x - src_circle_x, src.y - src_circle_y])
            angle_c1 = self._angle_between_vectors(c1_to_src_vector, v1_normal)

            c2_to_dest_vector = np.array(
                [dest.x - dest_circle_x, dest.y - dest_circle_y]
            )
            angle_c2 = self._angle_between_vectors(v1_normal, c2_to_dest_vector)

            total_distance = (
                straighline_distance
                + self._compute_arc_length(angle_rad=angle_c1)
                + self._compute_arc_length(angle_rad=angle_c2)
            )

            left_turn_1 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c1),
                turning_radian=angle_c1,
                direction=Direction.left,
                start_position=src,
                end_position=Position(
                    x=c1_tangent_point[0],
                    y=c1_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                circle_center=Position(
                    x=src_circle_x, y=src_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(left_turn_1)

            straight_1 = Movement(
                distance_cm=straighline_distance,
                turning_radian=0,
                direction=Direction.straight,
                start_position=Position(
                    x=c1_tangent_point[0],
                    y=c1_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                end_position=Position(
                    x=c2_tangent_point[0],
                    y=c2_tangent_point[1],
                    locationType=LocationType.empty,
                ),
            )
            moves_to_make.append(straight_1)

            left_turn_2 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c2),
                turning_radian=angle_c2,
                direction=Direction.left,
                start_position=Position(
                    x=c2_tangent_point[0],
                    y=c2_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                end_position=dest,
                circle_center=Position(
                    x=dest_circle_x, y=dest_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(left_turn_2)

            # print(f"""
            #       Travel total: {total_distance}
            #       1. Left by: {angle_c1}
            #       2. Straight by: {straighline_distance}
            #       3. Left by: {angle_c2}
            #       """)

        elif move_index == 1:  # [Direction.left, Direction.straight, Direction.right],
            # if distance < CAR_TURNING_RADIUS * 2:
            #     print("Edge Case: Distance cannot be less than 2 * r")
            #     return total_distance, moves_to_make

            v1 = np.array([dest_circle_x - src_circle_x, dest_circle_y - src_circle_y])
            a_length = CAR_TURNING_RADIUS
            h_length = distance / 2
            anticlockwise_rotation_radians = -self._compute_arccos(a_length / h_length)

            c1_normal_vector = self._rotate_vector(
                vector=v1, radians=anticlockwise_rotation_radians
            )
            c1_normal_vector = self._normalize_vector(vector=c1_normal_vector)

            c1_tangent_point = (
                np.array([src_circle_x, src_circle_y])
                + CAR_TURNING_RADIUS * c1_normal_vector
            )
            c2_tangent_point = (
                np.array([dest_circle_x, dest_circle_y])
                - CAR_TURNING_RADIUS * c1_normal_vector
            )

            straight_line_vector = c2_tangent_point - c1_tangent_point
            straighline_distance, straight_line_angle_of_travel = (
                self._vector_properties(straight_line_vector)
            )

            c1_to_src_vector = np.array([src.x - src_circle_x, src.y - src_circle_y])
            angle_c1 = self._angle_between_vectors(c1_to_src_vector, c1_normal_vector)

            c2_to_dest_vector = np.array(
                [dest.x - dest_circle_x, dest.y - dest_circle_y]
            )
            angle_c2 = self._angle_between_vectors(
                c2_to_dest_vector, c1_normal_vector * -1
            )

            total_distance = (
                straighline_distance
                + self._compute_arc_length(angle_rad=angle_c1)
                + self._compute_arc_length(angle_rad=angle_c2)
            )

            left_turn_1 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c1),
                turning_radian=angle_c1,
                direction=Direction.left,
                start_position=src,
                end_position=Position(
                    x=c1_tangent_point[0],
                    y=c1_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                circle_center=Position(
                    x=src_circle_x, y=src_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(left_turn_1)

            straight_1 = Movement(
                distance_cm=straighline_distance,
                turning_radian=0,
                direction=Direction.straight,
                start_position=Position(
                    x=c1_tangent_point[0],
                    y=c1_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                end_position=Position(
                    x=c2_tangent_point[0],
                    y=c2_tangent_point[1],
                    locationType=LocationType.empty,
                ),
            )
            moves_to_make.append(straight_1)

            right_turn_1 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c2),
                turning_radian=angle_c2,
                direction=Direction.right,
                start_position=Position(
                    x=c2_tangent_point[0],
                    y=c2_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                end_position=dest,
                circle_center=Position(
                    x=dest_circle_x, y=dest_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(right_turn_1)

            # print(f"{moves_to_make=}")

            # print(f"""
            #       Travel total: {total_distance}
            #       1. Left by: {angle_c1}
            #       2. Straight by: {straighline_distance}
            #       3. Right by: {angle_c2}
            #       """)

        elif move_index == 2:
            if distance > CAR_TURNING_RADIUS * 4:
                return total_distance, moves_to_make

            v1 = np.array([dest_circle_x - src_circle_x, dest_circle_y - src_circle_y])
            a_length = distance / 2
            h_length = CAR_TURNING_RADIUS * 2
            clockwise_rotation_radians = -self._compute_arccos(a_length / h_length)

            c1_normal_vector = self._rotate_vector(
                vector=v1, radians=clockwise_rotation_radians
            )
            c1_normal_vector = self._normalize_vector(vector=c1_normal_vector)

            c3_center = (
                np.array([src_circle_x, src_circle_y])
                + 2 * CAR_TURNING_RADIUS * c1_normal_vector
            )

            c2_normal_vector = c3_center - np.array([dest_circle_x, dest_circle_y])
            c2_normal_vector = self._normalize_vector(vector=c2_normal_vector)

            c1_center_to_start = np.array([src.x - src_circle_x, src.y - src_circle_y])
            c1_center_to_end = (
                np.array([src_circle_x, src_circle_y])
                + CAR_TURNING_RADIUS * c1_normal_vector
            )
            angle_c1 = self._angle_between_vectors(
                v1=c1_center_to_start, v2=c1_normal_vector
            )

            c3_start = c1_normal_vector
            c3_end = c3_center - CAR_TURNING_RADIUS * c2_normal_vector
            angle_c3 = self._angle_between_vectors(
                v1=-c2_normal_vector, v2=-c1_normal_vector
            )

            c2_start = (
                np.array([dest_circle_x, dest_circle_y])
                + CAR_TURNING_RADIUS * c2_normal_vector
            )
            c2_center_to_end = np.array(
                [dest.x - dest_circle_x, dest.y - dest_circle_y]
            )
            angle_c2 = self._angle_between_vectors(
                v1=c2_normal_vector, v2=c2_center_to_end
            )

            total_distance = (
                self._compute_arc_length(angle_rad=angle_c1)
                + self._compute_arc_length(angle_rad=angle_c2)
                + self._compute_arc_length(angle_rad=angle_c3)
            )

            # print(f"""
            #       Travel total: {total_distance}
            #       1. Left by: {angle_c1}
            #       2. Right by: {angle_c3}
            #       3. Left by: {angle_c2}
            #       """)

            left_turn_1 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c1),
                turning_radian=angle_c1,
                direction=Direction.left,
                start_position=src,
                end_position=Position(
                    x=c1_center_to_end[0],
                    y=c1_center_to_end[1],
                    locationType=LocationType.empty,
                ),
                circle_center=Position(
                    x=src_circle_x, y=src_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(left_turn_1)

            right_turn_1 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c3),
                turning_radian=angle_c3,
                direction=Direction.right,
                start_position=Position(
                    x=c1_center_to_end[0],
                    y=c1_center_to_end[1],
                    locationType=LocationType.empty,
                ),
                end_position=Position(
                    x=c3_end[0], y=c3_end[1], locationType=LocationType.empty
                ),
                circle_center=Position(
                    x=c3_center[0], y=c3_center[1], locationType=LocationType.empty
                ),
            )
            moves_to_make.append(right_turn_1)

            left_turn_2 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c2),
                turning_radian=angle_c2,
                direction=Direction.left,
                start_position=Position(
                    x=c3_end[0], y=c3_end[1], locationType=LocationType.empty
                ),
                end_position=dest,
                circle_center=Position(
                    x=dest_circle_x, y=dest_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(left_turn_2)

        elif move_index == 3:  # [Direction.right, Direction.straight, Direction.left],

            if distance < CAR_TURNING_RADIUS * 2:
                return total_distance, moves_to_make

            v1 = np.array([dest_circle_x - src_circle_x, dest_circle_y - src_circle_y])
            a_length = CAR_TURNING_RADIUS
            h_length = distance / 2
            anticlockwise_rotation_radians = self._compute_arccos(a_length / h_length)

            c1_normal_vector = self._rotate_vector(
                vector=v1, radians=anticlockwise_rotation_radians
            )
            c1_normal_vector = self._normalize_vector(vector=c1_normal_vector)

            c1_tangent_point = (
                np.array([src_circle_x, src_circle_y])
                + CAR_TURNING_RADIUS * c1_normal_vector
            )
            c2_tangent_point = (
                np.array([dest_circle_x, dest_circle_y])
                - CAR_TURNING_RADIUS * c1_normal_vector
            )

            straight_line_vector = c2_tangent_point - c1_tangent_point
            straighline_distance, straight_line_angle_of_travel = (
                self._vector_properties(straight_line_vector)
            )

            c1_to_src_vector = np.array([src.x - src_circle_x, src.y - src_circle_y])
            angle_c1 = self._angle_between_vectors(c1_normal_vector, c1_to_src_vector)

            c2_to_dest_vector = np.array(
                [dest.x - dest_circle_x, dest.y - dest_circle_y]
            )
            angle_c2 = self._angle_between_vectors(
                c1_normal_vector * -1, c2_to_dest_vector
            )

            total_distance = (
                straighline_distance
                + self._compute_arc_length(angle_rad=angle_c1)
                + self._compute_arc_length(angle_rad=angle_c2)
            )

            # print(f"""
            #       Travel total: {total_distance}
            #       1. Right by: {angle_c1}
            #       2. Straight by: {straighline_distance}
            #       3. Left by: {angle_c2}
            #       """)

            right_turn_1 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c1),
                turning_radian=angle_c1,
                direction=Direction.right,
                start_position=src,
                end_position=Position(
                    x=c1_tangent_point[0],
                    y=c1_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                circle_center=Position(
                    x=src_circle_x, y=src_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(right_turn_1)

            straight_1 = Movement(
                distance_cm=straighline_distance,
                turning_radian=0,
                direction=Direction.straight,
                start_position=Position(
                    x=c1_tangent_point[0],
                    y=c1_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                end_position=Position(
                    x=c2_tangent_point[0],
                    y=c2_tangent_point[1],
                    locationType=LocationType.empty,
                ),
            )
            moves_to_make.append(straight_1)

            left_turn_1 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c2),
                turning_radian=angle_c2,
                direction=Direction.left,
                start_position=Position(
                    x=c2_tangent_point[0],
                    y=c2_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                end_position=dest,
                circle_center=Position(
                    x=dest_circle_x, y=dest_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(left_turn_1)

        elif move_index == 4:  # [Direction.right, Direction.straight, Direction.right]
            v1 = np.array([dest_circle_x - src_circle_x, dest_circle_y - src_circle_y])
            v1_normal = np.array([-v1[1], v1[0]])

            v1_normal = self._normalize_vector(vector=v1_normal)

            c1_tangent_point = (
                np.array([src_circle_x, src_circle_y]) + CAR_TURNING_RADIUS * v1_normal
            )
            c2_tangent_point = c1_tangent_point + v1
            straighline_distance, straight_line_angle_of_travel = (
                self._vector_properties(v1)
            )

            c1_to_src_vector = np.array([src.x - src_circle_x, src.y - src_circle_y])
            angle_c1 = self._angle_between_vectors(v1_normal, c1_to_src_vector)

            c2_to_dest_vector = np.array(
                [dest.x - dest_circle_x, dest.y - dest_circle_y]
            )
            angle_c2 = self._angle_between_vectors(c2_to_dest_vector, v1_normal)

            total_distance = (
                straighline_distance
                + self._compute_arc_length(angle_rad=angle_c1)
                + self._compute_arc_length(angle_rad=angle_c2)
            )

            # print(f"""
            #       Travel total: {total_distance}
            #       1. Right by: {angle_c1}
            #       2. Straight by: {straighline_distance}
            #       3. Right by: {angle_c2}
            #       """)

            right_turn_1 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c1),
                turning_radian=angle_c1,
                direction=Direction.right,
                start_position=src,
                end_position=Position(
                    x=c1_tangent_point[0],
                    y=c1_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                circle_center=Position(
                    x=src_circle_x, y=src_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(right_turn_1)

            straight_1 = Movement(
                distance_cm=straighline_distance,
                turning_radian=0,
                direction=Direction.straight,
                start_position=Position(
                    x=c1_tangent_point[0],
                    y=c1_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                end_position=Position(
                    x=c2_tangent_point[0],
                    y=c2_tangent_point[1],
                    locationType=LocationType.empty,
                ),
            )
            moves_to_make.append(straight_1)

            right_turn_2 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c2),
                turning_radian=angle_c2,
                direction=Direction.right,
                start_position=Position(
                    x=c2_tangent_point[0],
                    y=c2_tangent_point[1],
                    locationType=LocationType.empty,
                ),
                end_position=dest,
                circle_center=Position(
                    x=dest_circle_x, y=dest_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(right_turn_2)

        elif move_index == 5:

            if distance > CAR_TURNING_RADIUS * 4:
                return total_distance, moves_to_make
            elif distance < CAR_TURNING_RADIUS * 2:
                return total_distance, moves_to_make

            v1 = np.array([dest_circle_x - src_circle_x, dest_circle_y - src_circle_y])
            a_length = distance / 2
            h_length = CAR_TURNING_RADIUS * 2
            anticlockwise_rotation_radians = self._compute_arccos(a_length / h_length)

            c1_normal_vector = self._rotate_vector(
                vector=v1, radians=anticlockwise_rotation_radians
            )
            c1_normal_vector = self._normalize_vector(vector=c1_normal_vector)

            c3_center = (
                np.array([src_circle_x, src_circle_y])
                + 2 * CAR_TURNING_RADIUS * c1_normal_vector
            )

            c2_normal_vector = c3_center - np.array([dest_circle_x, dest_circle_y])
            c2_normal_vector = self._normalize_vector(vector=c2_normal_vector)

            c1_center_to_start = np.array([src.x - src_circle_x, src.y - src_circle_y])
            c1_end = (
                np.array([src_circle_x, src_circle_y])
                + CAR_TURNING_RADIUS * c1_normal_vector
            )
            angle_c1 = self._angle_between_vectors(
                v1=c1_normal_vector, v2=c1_center_to_start
            )

            c3_start = c1_end
            c3_end = c3_center - CAR_TURNING_RADIUS * c2_normal_vector
            angle_c3 = self._angle_between_vectors(
                v1=-c1_normal_vector, v2=-c2_normal_vector
            )

            c2_start = (
                np.array([dest_circle_x, dest_circle_y])
                + CAR_TURNING_RADIUS * c2_normal_vector
            )
            c2_center_to_end = np.array(
                [dest.x - dest_circle_x, dest.y - dest_circle_y]
            )
            angle_c2 = self._angle_between_vectors(
                v1=c2_center_to_end, v2=c2_normal_vector
            )

            total_distance = (
                self._compute_arc_length(angle_rad=angle_c1)
                + self._compute_arc_length(angle_rad=angle_c2)
                + self._compute_arc_length(angle_rad=angle_c3)
            )

            # print(f"""
            #       Travel total: {total_distance}
            #       1. Right by: {angle_c1}
            #       2. Left by: {angle_c3}
            #       3. Right by: {angle_c2}
            #       """)

            right_turn_1 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c1),
                turning_radian=angle_c1,
                direction=Direction.right,
                start_position=src,
                end_position=Position(
                    x=c1_end[0],
                    y=c1_end[1],
                    locationType=LocationType.empty,
                ),
                circle_center=Position(
                    x=src_circle_x, y=src_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(right_turn_1)

            left_turn_1 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c3),
                turning_radian=angle_c3,
                direction=Direction.left,
                start_position=Position(
                    x=c1_end[0],
                    y=c1_end[1],
                    locationType=LocationType.empty,
                ),
                end_position=Position(
                    x=c2_start[0],
                    y=c2_start[1],
                    locationType=LocationType.empty,
                ),
                circle_center=Position(
                    x=c3_center[0], y=c3_center[1], locationType=LocationType.empty
                ),
            )
            moves_to_make.append(left_turn_1)

            right_turn_2 = Movement(
                distance_cm=self._compute_arc_length(angle_rad=angle_c2),
                turning_radian=angle_c2,
                direction=Direction.right,
                start_position=Position(
                    x=c2_start[0],
                    y=c2_start[1],
                    locationType=LocationType.empty,
                ),
                end_position=dest,
                circle_center=Position(
                    x=dest_circle_x, y=dest_circle_y, locationType=LocationType.empty
                ),
            )
            moves_to_make.append(right_turn_2)

        else:
            pass

        # if self.is_safe_movement(moves_to_make) == False:
        #     total_distance = math.inf
        return total_distance, moves_to_make

    def _map_obstacle_to_actual_location(self, pos: Position):
        new_pos = Position(
            x=(pos.x + 0.5) * GRID_SIZE,
            y=(pos.y + 0.5) * GRID_SIZE,
            locationType=pos.locationType,
            facing=pos.facing,
        )
        return new_pos

    def _plan_landing_zones(self):
        for y in range(GRID_COUNT):
            for x in range(GRID_COUNT):
                position = self.game.arena[y][x]
                if position.locationType == LocationType.obstacle:

                    if position.facing == Facing.east:

                        self.game.arena[y][
                            x + LANDING_DISTANCE
                        ].locationType = LocationType.landing
                        self.game.arena[y][x + LANDING_DISTANCE].facing = Facing.west
                        self.game.arena[y][
                            x + LANDING_DISTANCE
                        ].result = position.result
                        self.goals.append(
                            self._map_obstacle_to_actual_location(
                                self.game.arena[y][x + LANDING_DISTANCE]
                            )
                        )

                    elif position.facing == Facing.north:

                        self.game.arena[y + LANDING_DISTANCE][
                            x
                        ].locationType = LocationType.landing
                        self.game.arena[y + LANDING_DISTANCE][x].facing = Facing.south
                        self.game.arena[y + LANDING_DISTANCE][
                            x
                        ].result = position.result
                        self.goals.append(
                            self._map_obstacle_to_actual_location(
                                self.game.arena[y + LANDING_DISTANCE][x]
                            )
                        )

                    elif position.facing == Facing.west:

                        self.game.arena[y][
                            x - LANDING_DISTANCE
                        ].locationType = LocationType.landing
                        self.game.arena[y][x - LANDING_DISTANCE].facing = Facing.east
                        self.game.arena[y][
                            x - LANDING_DISTANCE
                        ].result = position.result
                        self.goals.append(
                            self._map_obstacle_to_actual_location(
                                self.game.arena[y][x - LANDING_DISTANCE]
                            )
                        )

                    else:

                        self.game.arena[y - LANDING_DISTANCE][
                            x
                        ].locationType = LocationType.landing
                        self.game.arena[y - LANDING_DISTANCE][x].facing = Facing.north
                        self.game.arena[y - LANDING_DISTANCE][
                            x
                        ].result = position.result
                        self.goals.append(
                            self._map_obstacle_to_actual_location(
                                self.game.arena[y - LANDING_DISTANCE][x]
                            )
                        )
                    self.goals_to_id_mapping[len(self.goals) - 1] = position.id

        # if len(self.goals) != OBSTACLE_COUNT:
        #     self.game = None

    # def _get_source_cirle_position(self, position: Position):

    def _get_circle_position(self, position: Position, move: Direction):
        x = position.x
        y = position.y
        if position.facing == Facing.east:
            if move == Direction.left:
                return x, y + CAR_TURNING_RADIUS
            elif move == Direction.right:
                return x, y - CAR_TURNING_RADIUS
        elif position.facing == Facing.north:
            if move == Direction.left:
                return x - CAR_TURNING_RADIUS, y
            elif move == Direction.right:
                return x + CAR_TURNING_RADIUS, y
        elif position.facing == Facing.west:
            if move == Direction.left:
                return x, y - CAR_TURNING_RADIUS
            elif move == Direction.right:
                return x, y + CAR_TURNING_RADIUS
        elif position.facing == Facing.south:
            if move == Direction.left:
                return x + CAR_TURNING_RADIUS, y
            elif move == Direction.right:
                return x - CAR_TURNING_RADIUS, y

        # print(f"Error when getting circle position for {position} direction: {move}")
        return None, None

    def _let_salesman_travel(self):

        def is_home(pos: Position):
            return pos.x == CAR_X_START_POS and pos.y == CAR_Y_START_POS

        def recursion(
            obstacles_explored: List[int],
            total_cost_incurred: float,
            current_obstacle_id: int,
            moves: List[int],
        ):
            copy_moves = moves[:]
            copy_moves.append(current_obstacle_id)

            if len(obstacles_explored) == OBSTACLE_COUNT:
                # moves.append(len(self.shortest_distance_matrix) - 1)
                return (
                    total_cost_incurred,
                    copy_moves,
                )

            shortest_distance = math.inf
            min_moves = None

            for index in range(len(self.goals)):

                # if is_home(pos=obstacle):
                #     continue

                if (
                    index == len(self.goals) - 1 or index in obstacles_explored
                ):  ## Home or obstacle has already been explored
                    continue

                copy_obstacles_explored = obstacles_explored[:]
                copy_obstacles_explored.append(index)
                copy_distance = (
                    total_cost_incurred
                    + self.shortest_distance_matrix[current_obstacle_id][index].distance
                )
                working_distance, working_moves = recursion(
                    obstacles_explored=copy_obstacles_explored,
                    total_cost_incurred=copy_distance,
                    current_obstacle_id=index,
                    moves=copy_moves,
                )

                if working_distance < shortest_distance:
                    shortest_distance = working_distance
                    min_moves = working_moves

                # if len(obstacles_explored) == 0:
                #     print(f"Distance: {working_distance} Series: {working_moves}")

            return shortest_distance, min_moves

        shortest_distance, min_moves = recursion(
            obstacles_explored=[],
            total_cost_incurred=0,
            current_obstacle_id=len(self.goals) - 1,
            moves=[],
        )

        if min_moves is None:
            self.sale_path = None
            self.game = None
            return

        movement_seq = []
        movement_string = []
        for src_index in range(len(min_moves) - 1):
            dest_index = (src_index + 1) % len(min_moves)
            y = min_moves[src_index]
            x = min_moves[dest_index]

            movement_seq += self.shortest_distance_matrix[y][x].movements_to_take
            movement_string += self.convert_to_command(self.shortest_distance_matrix[y][x].movements_to_take)
            # movement_seq.append(
            #     Movement(
            #         distance_cm=0,
            #         turning_radian=0,
            #         direction=Direction.straight,
            #         start_position=Position(
            #             x=-1, y=-1, locationType=LocationType.empty
            #         ),
            #         end_position=Position(x=-1, y=-1, locationType=LocationType.empty),
            #     )
            # )
        # print(self.convert_to_command(movement_seq))

        self.sale_path = TravelledSalesman(
            total_distance=shortest_distance,
            obstacle_seq=min_moves,
            movement_path=movement_seq,
            movement_string=movement_string,
        )
        # self.string_solution = self.convert_to_command(movement_seq)

    def convert_to_array(self, val):
        return np.array([val.x, val.y], dtype=int)
    def closest_distance(self, start1, end1, start2, end2):


        p1 = self.convert_to_array(start1)
        p2 = self.convert_to_array(end1)
        p3 = self.convert_to_array(start2)
        p4 = self.convert_to_array(end2)

        d1 = p2 - p1  # Direction vector of line segment 1
        d2 = p4 - p3  # Direction vector of line segment 2
        r = p1 - p3

        a = np.dot(d1, d1)  # Length squared of segment 1
        b = np.dot(d1, d2)  # Dot product of the direction vectors
        c = np.dot(d2, d2)  # Length squared of segment 2
        e = np.dot(r, d1)  # Projection of r onto d1
        f = np.dot(r, d2)  # Projection of r onto d2

        # Solve for s and t
        denominator = a * c - b * b
        if denominator == 0:  # Parallel lines
            # Handle parallel case by finding distance to endpoints
            return np.min([
                np.linalg.norm(p1 - p3),
                np.linalg.norm(p1 - p4),
                np.linalg.norm(p2 - p3),
                np.linalg.norm(p2 - p4),
            ])

        # Calculate parameter values for the closest points
        s_numer = b * f - c * e
        t_numer = a * f - b * e

        s = s_numer / denominator
        t = t_numer / denominator

        # Check if the segments intersect
        if 0 <= s <= 1 and 0 <= t <= 1:
            return 0.0  # Segments intersect

        # Clamp the values of s and t to the range [0, 1]
        s = np.clip(s, 0, 1)
        t = np.clip(t, 0, 1)

        # Calculate the closest points
        closest_point1 = p1 + s * d1
        closest_point2 = p3 + t * d2

        # Return the distance between the closest points
        return np.linalg.norm(closest_point1 - closest_point2)

    def closest_distance_point_to_line(self, start, end, point):
        p1 = self.convert_to_array(start)
        p2 = self.convert_to_array(end)
        p = np.array([point.x * GRID_SIZE + GRID_SIZE // 2, point.y * GRID_SIZE + GRID_SIZE // 2], dtype=int)
        line_vector = p2 - p1  # Direction vector of the line segment
        point_vector = p - p1  # Vector from the start of the line segment to the point

        line_length_squared = np.dot(line_vector, line_vector)

        if line_length_squared == 0:  # The segment is just a point
            return np.linalg.norm(p - p1)

        # Projection factor
        t = np.dot(point_vector, line_vector) / line_length_squared
        t = np.clip(t, 0, 1)  # Clamp to the range [0, 1]

        # Find the closest point on the line segment
        closest_point = p1 + t * line_vector

        # Return the distance from the point to the closest point on the segment
        return np.linalg.norm(p - closest_point)

    def check_straight_movement(self, movement: Movement):
        start = movement.start_position
        end = movement.end_position


        # for edge in self.edges:
        #     distance = self.closest_distance(start, end, edge[0], edge[1])
        #     if distance < SAFETY_DISTANCE_EDGE:
        #         return False

        for obstacle in self.obstacle:
            distance = self.closest_distance_point_to_line(start, end, obstacle)
            if distance < SAFETY_DISTANCE_OBSTACLE:
                return False
        return True

    def check_turn_movement(self, movement: Movement):
        def calculate_angle(p1, p2):
            p1 = self.convert_to_array(p1)
            p2 = self.convert_to_array(p2)
            delta_x = p2[0] - p1[0]
            delta_y = p2[1] - p1[1]
            angle = np.arctan2(delta_y, delta_x)
            if angle < 0:
                angle += 2 * np.pi

            return angle

        def calculate_distance(p1, p2):
            p1 = self.convert_to_array(p1)
            p2 = self.convert_to_array(p2)

            distance = np.linalg.norm(p2 - p1)

            return distance

        def closest_point_on_segment(point, start, end):
            point = self.convert_to_array(point)
            start =  self.convert_to_array(start)
            end =  self.convert_to_array(end)
            segment = end - start
            segment_length_squared = np.dot(segment, segment)
            if segment_length_squared == 0:
                return start
            t = np.dot(point - start, segment) / segment_length_squared
            t = np.clip(t, 0, 1)
            closest_point = start + t * segment

            return closest_point

        def modulo_angle(angle):
            return angle % (2 * np.pi)

        for obstacle in self.obstacle:
            pos = Position(x=obstacle.x * GRID_SIZE + GRID_SIZE // 2, y=obstacle.y * GRID_SIZE + GRID_SIZE // 2, locationType=LocationType.empty)
            angle = calculate_angle(movement.circle_center, pos)
            start_angle = calculate_angle(movement.circle_center, movement.start_position)
            end_angle = calculate_angle(movement.circle_center, movement.end_position)

            if (movement.direction == Direction.left and movement.distance_cm > 0) or (movement.direction == Direction.right and movement.distance_cm <= 0):
                start_angle = modulo_angle(start_angle - ANGLE_SUPPLEMENT)
                end_angle = modulo_angle(end_angle + ANGLE_SUPPLEMENT)
                if (start_angle < end_angle and angle >= start_angle and angle <= end_angle) or (start_angle > end_angle and angle >= start_angle):
                    distance = calculate_distance(movement.circle_center, pos)
                    if distance < SAFETY_DISTANCE_TURNING_OBSTACLE:
                        return False

            elif (movement.direction == Direction.right and movement.distance_cm > 0) or (movement.direction == Direction.left and movement.distance_cm <= 0):
                start_angle = modulo_angle(start_angle + ANGLE_SUPPLEMENT)
                end_angle = modulo_angle(end_angle - ANGLE_SUPPLEMENT)
                # print(angle,start_angle, end_angle)
                if (start_angle > end_angle and angle <= start_angle and angle >= end_angle) or (start_angle < end_angle and angle <= start_angle):
                    distance = calculate_distance(movement.circle_center, pos)
                    # print(f"Distance: {distance}")
                    if distance < SAFETY_DISTANCE_TURNING_OBSTACLE:
                        return False

        ##COMMENT THIS OUT IF CRASH
        # for edge in self.edges:
        #     closest_point = closest_point_on_segment(movement.circle_center, edge[0], edge[1])
        #     closest_point = Position(x=closest_point[0], y=closest_point[1], locationType=LocationType.empty)
        #     distance = calculate_distance(closest_point, movement.circle_center)
        #     if distance < SAFETY_DISTANCE_TURNING_EDGE:
        #         return False

        return True
    def is_safe_movement(self, moves_to_make: List[Movement]):
        for move in moves_to_make:
            if move.start_position.x == CAR_X_START_POS and move.start_position.y == CAR_Y_START_POS:
                continue
            if move.turning_radian != 0:
                # print(f"Handling turn: {move}")
                if self.check_turn_movement(move) is False:
                    return False
            else:
                # print(f"Handle straight: {move}")
                if self.check_straight_movement(move) is False:
                    return False
        return True


    def convert_to_command(self, movement_seq):
        command_dict = {
            "straight": "S",
            "right": "R",
            "left": "L",
            "forward": "F",
            "backward": "B",
            "reset": "G",
        }

        def calculate_degree(distance):
            radian = distance / CAR_TURNING_RADIUS
            degree = radian * (180 / math.pi)
            return degree

        command_list = []
        for move in movement_seq:

            if move.distance_cm == 0 or move.distance_cm is None:
                continue

            if move.start_position.x == -1:
                command = "G"
            else:
                distance = move.distance_cm
                backwards = False
                if distance < 0:
                    backwards = True
                    distance = -distance

                direction = move.direction
                if direction == Direction.right:
                    degree = calculate_degree(distance)
                    formatted_degree = f"{int(degree):03d}"
                    command = "R" + formatted_degree
                elif direction == Direction.straight:
                    formatted_distance = f"{int(distance):03d}"
                    command = "S" + formatted_distance
                elif direction == Direction.left:
                    degree = calculate_degree(distance)
                    formatted_degree = f"{int(degree):03d}"
                    command = "L" + formatted_degree

                if backwards:
                    command = command[:1] + "B" + command[1:]
                else:
                    command = command[:1] + "F" + command[1:]

            command_list.append(command)

        return command_list
        message = ''.join(command_list)


        return message
        # return command_list

--------------------------------------------------------------------------------
